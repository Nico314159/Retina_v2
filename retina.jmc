import "math";

new tags.blocks(airs) {
    "values": [
        "minecraft:air",
        "minecraft:cave_air",
        "minecraft:void_air"
	]
}

new tags.blocks(anvil) {
    "values": ["#minecraft:anvil"]
}
new tags.blocks(attached_stem) {
	"values": [
		"minecraft:attached_melon_stem",
		"minecraft:attached_pumpkin_stem"
	]
}
new tags.blocks(bed) {
	"values": ["#minecraft:beds"]
}
new tags.blocks(beetroot) {
	"values": ["minecraft:beetroots"]
}
new tags.blocks(brewing_stand) {
	"values": ["minecraft:brewing_stand"]
}
new tags.blocks(button) {
	"values": ["minecraft:buttons"]
}
new tags.blocks(cactus_shaped) {
    "values": [
		"minecraft:cactus",
		"minecraft:dragon_egg"
	]
}
new tags.blocks(campfire) {
    "values": ["#minecraft:campfires"]
}
new tags.blocks(carpet) {
    "values": [
        "#minecraft:wool_carpets",
        "minecraft:moss_carpet"
    ]
}
new tags.blocks(cauldron) {
    "values": ["#minecraft:cauldrons"]
}
new tags.blocks(chain) {
    "values": ["minecraft:chain"]
}
new tags.blocks(chests) {
    "values": [
		"minecraft:chest",
		"minecraft:ender_chest",
		"minecraft:trapped_chest"
	]
}
new tags.blocks(composter) {
    "values": ["minecraft:composter"]
}
new tags.blocks(conduit) {
    "values": ["minecraft:conduit"]
}
new tags.blocks(door) {
    "values": ["#minecraft:doors"]
}
new tags.blocks(farmland_shaped) {
    "values": [
        "minecraft:farmland",
        "minecraft:dirt_path"
    ]
}
new tags.blocks(fence) {
    "values": ["#minecraft:fences"]
}
new tags.blocks(fence_gate) {
    "values": ["#minecraft:fence_gates"]
}
new tags.blocks(grass_shaped) {
    "values": [
		"minecraft:grass",
		"minecraft:fern",
		"minecraft:dead_bush",
		"minecraft:warped_roots",
		"minecraft:crimson_roots",
		"minecraft:small_dripleaf"
	]
}
new tags.blocks(ladder) {
    "values": ["minecraft:ladder"]
}
new tags.blocks(lantern) {
    "values": [
        "minecraft:lantern",
        "minecraft:soul_lantern"
    ]
}
new tags.blocks(mushroom_shaped) {
	"values": [
		"minecraft:brown_mushroom",
		"minecraft:red_mushroom",
		"minecraft:flower_pot",
		"minecraft:potted_oak_sapling",
		"minecraft:potted_spruce_sapling",
		"minecraft:potted_birch_sapling",
		"minecraft:potted_jungle_sapling",
		"minecraft:potted_acacia_sapling",
		"minecraft:potted_dark_oak_sapling",
		"minecraft:potted_fern",
		"minecraft:potted_dandelion",
		"minecraft:potted_poppy",
		"minecraft:potted_blue_orchid",
		"minecraft:potted_allium",
		"minecraft:potted_azure_bluet",
		"minecraft:potted_red_tulip",
		"minecraft:potted_orange_tulip",
		"minecraft:potted_white_tulip",
		"minecraft:potted_pink_tulip",
		"minecraft:potted_oxeye_daisy",
		"minecraft:potted_cornflower",
		"minecraft:potted_lily_of_the_valley",
		"minecraft:potted_wither_rose",
		"minecraft:potted_red_mushroom",
		"minecraft:potted_brown_mushroom",
		"minecraft:potted_dead_bush",
		"minecraft:potted_cactus",
		"minecraft:potted_bamboo",
		"minecraft:potted_crimson_fungus",
		"minecraft:potted_warped_fungus",
		"minecraft:potted_crimson_roots",
		"minecraft:potted_warped_roots",
		"minecraft:potted_azalea_bush",
		"minecraft:potted_flowering_azalea_bush"
	]
}
new tags.blocks(pane_shaped) {
	"values": [
		"minecraft:iron_bars",
		"minecraft:glass_pane",
		"minecraft:white_stained_glass_pane",
		"minecraft:orange_stained_glass_pane",
		"minecraft:magenta_stained_glass_pane",
		"minecraft:light_blue_stained_glass_pane",
		"minecraft:yellow_stained_glass_pane",
		"minecraft:lime_stained_glass_pane",
		"minecraft:pink_stained_glass_pane",
		"minecraft:gray_stained_glass_pane",
		"minecraft:light_gray_stained_glass_pane",
		"minecraft:cyan_stained_glass_pane",
		"minecraft:purple_stained_glass_pane",
		"minecraft:blue_stained_glass_pane",
		"minecraft:brown_stained_glass_pane",
		"minecraft:green_stained_glass_pane",
		"minecraft:red_stained_glass_pane",
		"minecraft:black_stained_glass_pane"
	]
}
new tags.blocks(pressure_plate) {
    "values": ["#minecraft:pressure_plates"]
}
new tags.blocks(rail) {
	"values": [
        "minecraft:rail",
		"minecraft:activator_rail",
		"minecraft:detector_rail",
		"minecraft:powered_rail"
	]
}
new tags.blocks(sapling) {
    "values": ["#minecraft:saplings"]
}
new tags.blocks(slab) {
    "values": ["#minecraft:slabs"]
}
new tags.blocks(sugar_cane_like) {
	"values": [
		"minecraft:sugar_cane",
		"minecraft:tall_seagrass"
	]
}
new tags.blocks(stair) {
    "values": ["#minecraft:stairs"]
}
new tags.blocks(standing_sign_or_banner) {
    "values": [
		"#minecraft:standing_signs",
		"minecraft:white_banner",
		"minecraft:orange_banner",
		"minecraft:magenta_banner",
		"minecraft:light_blue_banner",
		"minecraft:yellow_banner",
		"minecraft:lime_banner",
		"minecraft:pink_banner",
		"minecraft:gray_banner",
		"minecraft:light_gray_banner",
		"minecraft:cyan_banner",
		"minecraft:purple_banner",
		"minecraft:blue_banner",
		"minecraft:brown_banner",
		"minecraft:green_banner",
		"minecraft:red_banner",
		"minecraft:black_banner",
		"minecraft:twisting_vines_plant"
	]
}
new tags.blocks(trapdoor) {
    "values": ["#minecraft:trapdoors"]
}
new tags.blocks(vertical_torch) {
	"values": [
		"minecraft:torch",
		"minecraft:redstone_torch",
		"minecraft:soul_torch"
	]
}
new tags.blocks(wall) {
    "values": ["#minecraft:walls"]
}
new tags.blocks(wall_sign) {
    "values": ["#minecraft:wall_signs"]
}
new tags.blocks(wall_torch) {
	"values": [
		"minecraft:wall_torch",
		"minecraft:redstone_wall_torch",
		"minecraft:soul_wall_torch"
	]
}

//summon minecraft:marker 0 0 0 {Tags:["retina.height","retina.ignore"]};
$overflow_risk = 2147483647;
$overflow_risk /= SCALE;
$max_depth = 300;


class traverse {
    function setup() {
        // guard condition
        Hardcode.repeatList(
            "[i]",
            () => {
                $int_[i] = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[0] 1;
                $test_[i] = $int_[i];
                $test_[i] /= $overflow_risk;
                if (!$test_[i] matches -1..0) Text.tellraw(@a, "&<dark_red>[Error] &<red>Raycast [i] coordinate of &<$int_[i]> is out of range (-&<$overflow_risk>, &<$overflow_risk>)");
                //if (!$test_[i] matches -1..0) return 0;
            },
            ["X", "Z"] // not worried about Y since that's never gonna be high enough to overflow
        );
        
        $input_pitch = data get entity @s Rotation[1] 10;
        $input_yaw = data get entity @s Rotation[0] 10;
        Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
        Math.gimbal_to_vec();
        Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.X>, &<$output_vec3.Y>, &<$output_vec3.Z>]");

        execute anchored eyes run summon minecraft:marker ^ ^ ^ {Tags:["retina.height"]};
        $X = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[0] 1000;
        $Y = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[1] 1000;
        //$Y += 1620;
        $Z = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[2] 1000;
        kill @e[type=marker,tag=retina.height,limit=1];
        Hardcode.repeatList(
            "[i]",
            () => {
                $origin_[i] = $[i];
                $frac_origin_[i] = $[i];
                $frac_origin_[i] %= 1000;

                if ($output_vec3.[i] < 0) $sign_[i] = -1;
                if ($output_vec3.[i] >= 0) $sign_[i] = 1;

                $delta_[i] = 1000000;
                $delta_[i] /= $output_vec3.[i];
                $delta_[i] /= $sign_[i];

                $distance_[i] = $[i];
                $distance_[i] *= $sign_[i];
                $distance_[i] *= -1;
                $distance_[i] %= 1000;
                $distance_[i] *= $delta_[i];
                $distance_[i] /= 1000;

                if ($output_vec3.[i] == 0) $delta_[i] = 2147483647;
                if ($output_vec3.[i] == 0) $distance_[i] = 2147483647;

                $int_[i] = $[i];
                $int_[i] /= 1000;
                $frac_[i] = $[i];
                $frac_[i] %= 1000;
            },
            ["X", "Y", "Z"]
        );
        Text.tellraw(@a, "Origin: &<yellow>[&<$int_X>, &<$int_Y>, &<$int_Z>]");

        $step = 0;
        $end = 0;
        $offset_Y = data get entity @s Pos[1] -1000; 
        $offset_Y += $Y;
        if ($offset_Y matches 1619..1621) execute positioned ~ ~1.62 ~ run traverse.loop();
        if ($offset_Y matches 1269..1271) execute positioned ~ ~1.27 ~ run traverse.loop();
        if ($offset_Y matches 399..401) execute positioned ~ ~0.4 ~ run traverse.loop();
    }
    function loop() {
        // Find nearest axis
        $shortest_distance = $distance_X;
        $shortest_distance < $distance_Y;
        $shortest_distance < $distance_Z;
        if ($shortest_distance = $distance_Z) $nearest_axis = 2;
        if ($shortest_distance = $distance_Y) $nearest_axis = 1;
        if ($shortest_distance = $distance_X) $nearest_axis = 0;
        
        // Process data based on nearest axis
        if ($nearest_axis = 0 && $step < $max_depth && $end = 0) traverse.x();
        if ($nearest_axis = 1 && $step < $max_depth && $end = 0) traverse.y();
        if ($nearest_axis = 2 && $step < $max_depth && $end = 0) traverse.z();
    }
    function x() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>X");
        $distance_X += $delta_X;

        Hardcode.repeatList(
            "[i]",
            () => {
                $relative_[i] = $output_vec3.[i];
                $relative_[i] *= $shortest_distance;
                $relative_[i] /= 1000;
                $[i] = $relative_[i];
                $[i] += $origin_[i];

                $int_[i] = $[i];
                $int_[i] /= 1000;
                $frac_[i] = $[i];
                $frac_[i] %= 1000;
            },
            ["X", "Y", "Z"]
        );
        $distance_X += $delta_X;

        if ($sign_X = -1) execute positioned ~-1 ~0 ~0 run check.main();
        if ($sign_X = 1) execute positioned ~1 ~0 ~0 run check.main();
    }
    function y() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Y");
        $distance_Y += $delta_Y;

        Hardcode.repeatList(
            "[i]",
            () => {
                $relative_[i] = $output_vec3.[i];
                $relative_[i] *= $shortest_distance;
                $relative_[i] /= 1000;
                $[i] = $relative_[i];
                $[i] += $origin_[i];

                $int_[i] = $[i];
                $int_[i] /= 1000;
                $frac_[i] = $[i];
                $frac_[i] %= 1000;
            },
            ["X", "Y", "Z"]
        );

        if ($sign_Y = -1) execute positioned ~0 ~-1 ~0 run check.main();
        if ($sign_Y = 1) execute positioned ~0 ~1 ~0 run check.main();

    }
    function z() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Z");
        $distance_Z += $delta_Z;
        
        Hardcode.repeatList(
            "[i]",
            () => {
                $relative_[i] = $output_vec3.[i];
                $relative_[i] *= $shortest_distance;
                $relative_[i] /= 1000;
                $[i] = $relative_[i];
                $[i] += $origin_[i];

                $int_[i] = $[i];
                $int_[i] /= 1000;
                $frac_[i] = $[i];
                $frac_[i] %= 1000;
            },
            ["X", "Y", "Z"]
        );

        if ($sign_Z = -1) execute positioned ~0 ~0 ~-1 run check.main();
        if ($sign_Z = 1) execute positioned ~0 ~0 ~1 run check.main();
    }
}   


class check {
    function main() {
        $step ++;
        $end = false;

        check.block.main();
        if ($end) check.debug();
        
        if ($step >= $max_depth) $end = true;
        if ($step >= $max_depth) Text.tellraw(@a, "&<italic, light_purple>Failed to find anything within &<$step> blocks. End coordinates: &<bold>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
        if ($end = 0) traverse.loop();
    }
    class block {
        function main() {
            if (!block ~ ~ ~ #retina:airs) check.block.found();
            if ($end) {
                Text.tellraw(@a, "&<bold, underlined, gray>Block has been hit! Coordinates: &<blue>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
                if ($debug_gold = 1) setblock ~ ~ ~ gold_block;
            }
            if (!$end) {
                Text.tellraw(@a, "&<italic, white>No block... Coordinates: &<blue>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
            }
        }
        function found() {
            // clear residual data from `Surfaces`
            data remove storage retina:data Surfaces;
            data modify storage retina:data Surfaces set value {Top:[],Bottom:[],West:[],East:[],North:[],South:[]};
            check.block.get_hitbox();
            // See if the ray hits any surface
            if (data storage retina:data Surfaces) find_closest_surface.main(); 
            if ($end) $block_distance = $shortest_distance;
        }
        function get_hitbox() {
            $shape_found = false;
            Hardcode.repeatList(
                "[shape]",
                () => {
                    $block.[shape] = false;
                    if (!$shape_found) $block.[shape] ?= execute if block ~ ~ ~ #retina:[shape];
                    $shape_found += $block.[shape];
                    if ($block.[shape]) hitbox.[shape]();
                },
                ["slab", "stair"]
                // ["anvil", "attached_stem", "bed", "beetroot", "brewing_stand", "button", 
                // "cactus_shaped", "campfire", "carpet", "cauldron", "chain", "chest", "composter", "conduit", 
                // "door", "farmland_shaped", "fence_gate", "fence", "grass_shaped",
                // "ladder", "lantern", "mushroom_shaped", "pane_shaped", "pressure_plate", "rail", 
                // "sapling", "slab", "stair", "standing_sign_or_banner", "sugar_cane_like",
                // "trapdoor", "vertical_torch", "wall_sign", "wall_torch", "wall"]
            );
            if (!$shape_found) hitbox.cubic(); // if it doesn't match any special hitbox, assume it's a 1x1x1 cube.
        }
    }
    function debug() {
        if ($nearest_axis = 0) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>X");
        if ($nearest_axis = 1) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>Y");
        if ($nearest_axis = 2) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>Z");
    }
}

class find_closest_surface {
    function main() {
        // @within check.block.found()

        $min_distance_to_surface = 1733; // sqrt(3)
        Hardcode.repeatLists(
            ["[direction]", "[axis]", "[sign]"],
            () => {if (!$sign_[axis] = [sign] && $end == 0) find_closest_surface.[direction]();},
            [
                ["east", "west", "top", "bottom", "south", "north"],
                ["X", "X", "Y", "Y", "Z", "Z"],
                ["1", "-1", "1", "-1", "1", "-1"]
            ]
        );
    }
    function store_coords() {
        $x0 = data get storage retina:data List[-1][0];
            $x0 += $relative_X;
            $x0 -= $frac_origin_X;
        $y0 = data get storage retina:data List[-1][1];
            $y0 += $relative_Y;
            $y0 -= $frac_origin_Y;
        $z0 = data get storage retina:data List[-1][2];
            $z0 += $relative_Z;
            $z0 -= $frac_origin_Z;
        $x1 = data get storage retina:data List[-1][3];
            $x1 += $relative_X;
            $x1 -= $frac_origin_X;
        $y1 = data get storage retina:data List[-1][4];
            $y1 += $relative_Y;
            $y1 -= $frac_origin_Y;
        $z1 = data get storage retina:data List[-1][5];
            $z1 += $relative_Z;
            $z1 -= $frac_origin_Z;
    }
    function west() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.West;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[0] and List[3] should have the same values)
            Text.tellraw(@a, "&<italic>Relative X: &<!italic,light_purple,$relative_X>, &<white>x0: &<light_purple,$x0>");

            // If the current position is already in the plane of the surface, check if it is in the surface
            if ($relative_X = $x0 && $relative_Y >= $y0 && $relative_Y <= $y1 && $relative_Z >= $z0 && $relative_Z <= $z1) find_closest_surface.ray_already_in_surface();

            // If the current position is before the plane, check if it hits the surface and get the position of that intersection
            if ($relative_X < $x0) {
                $distance = $x0;
                $distance -= $relative_X;
                $distance *= 1000;
                $distance /= $delta_X;
                Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if ($distance < $min_distance_to_surface) {
                    $X_intersection = $x0; // Get x position of the intersection

                    // Get y position of the intersection
                    $Y_intersection = $distance;
                    $Y_intersection *= $delta_Y;
                    $Y_intersection /= 1000; 
                    $Y_intersection += $relative_Y; 

                    // Get z position of the intersection
                    $Z_intersection = $distance;
                    $Z_intersection *= $delta_Z;
                    $Z_intersection /= 1000;
                    $Z_intersection += $relative_Z;

                    // If the ray hits the surface, return this as the minimum distance and the contact surface
                    if ($Y_intersection >= $y0 && $Y_intersection <= $y1 && $Z_intersection >= $z0 && $Z_intersection <= $z1) find_closest_surface.ray_intersects_with_surface();
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function east() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.East;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[0] and List[3] should have the same values)
            Text.tellraw(@a, "&<italic>Relative X: &<!italic,light_purple,$relative_X>, &<white>x0: &<light_purple,$x0>");

            // If the current position is already in the plane of the surface, check if it is in the surface
            if ($relative_X = $x0 && $relative_Y >= $y0 && $relative_Y <= $y1 && $relative_Z >= $z0 && $relative_Z <= $z1) find_closest_surface.ray_already_in_surface();

            // If the current position is before the plane, check if it hits the surface and get the position of that intersection
            if ($relative_X > $x0) {
                $distance = $x0;
                $distance -= $relative_X;
                $distance *= 1000;
                $distance /= $delta_X;
                Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if ($distance < $min_distance_to_surface) {
                    $X_intersection = $x0; // Get x position of the intersection

                    // Get y position of the intersection
                    $Y_intersection = $distance;
                    $Y_intersection *= $delta_Y;
                    $Y_intersection /= 1000;
                    $Y_intersection += $relative_Y;

                    // Get z position of the intersection
                    $Z_intersection = $distance;
                    $Z_intersection *= $delta_Z;
                    $Z_intersection /= 1000;
                    $Z_intersection += $relative_Z;

                    // If the ray hits the surface, return this as the minimum distance and the contact surface
                    if ($Y_intersection >= $y0 && $Y_intersection <= $y1 && $Z_intersection >= $z0 && $Z_intersection <= $z1) find_closest_surface.ray_intersects_with_surface();
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function bottom() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.Bottom;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[1] and List[4] should have the same values)
            Text.tellraw(@a, "&<italic>Relative X: &<!italic,light_purple,$relative_X>, &<white>x0: &<light_purple,$x0>");

            // If the current position is already in the plane of the surface, check if it is in the surface
            if ($relative_Y = $y0 && $relative_X >= $x0 && $relative_X <= $x1 && $relative_Z >= $z0 && $relative_Z <= $z1) find_closest_surface.ray_already_in_surface();

            // If the current position is before the plane, check if it hits the surface and get the position of that intersection
            if ($relative_Y < $y0) {
                $distance = $y0;
                $distance -= $relative_Y;
                $distance *= 1000;
                $distance /= $delta_Y;
                Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if ($distance < $min_distance_to_surface) {
                    // Get x position of the intersection
                    $X_intersection = $distance;
                    $X_intersection *= $delta_X;
                    $X_intersection /= 1000;
                    $X_intersection += $relative_X;

                    // Get y position of the intersection (useful for retina:find_closest_surface/ray_intersects_with_surface)
                    $Y_intersection = $y0;

                    // Get z position of the intersection
                    $Z_intersection = $distance;
                    $Z_intersection *= $delta_Z;
                    $Z_intersection /= 1000;
                    $Z_intersection += $relative_Z;

                    // If the ray hits the surface, return this as the minimum distance and the contact surface
                    if ($X_intersection >= $x0 && $X_intersection <= $x1 && $Z_intersection >= $z0 && $Z_intersection <= $z1) find_closest_surface.ray_intersects_with_surface();
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function top() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.Top;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[1] and List[4] should have the same values)
            Text.tellraw(@a, "&<italic>Relative X: &<!italic,light_purple,$relative_X>, &<white>x0: &<light_purple,$x0>");

            // If the current position is already in the plane of the surface, check if it is in the surface
            if ($relative_Y = $y0 && $relative_X >= $x0 && $relative_X <= $x1 && $relative_Z >= $z0 && $relative_Z <= $z1) find_closest_surface.ray_already_in_surface();

            // If the current position is before the plane, check if it hits the surface and get the position of that intersection
            if ($relative_Y > $y0) {
                $distance = $y0;
                $distance -= $relative_Y;
                $distance *= 1000;
                $distance /= $delta_Y;
                Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if ($distance < $min_distance_to_surface) {
                    // Get x position of the intersection
                    $X_intersection = $distance;
                    $X_intersection *= $delta_X;
                    $X_intersection /= 1000;
                    $X_intersection += $relative_X;

                    // Get y position of the intersection (useful for retina:find_closest_surface/ray_intersects_with_surface)
                    $Y_intersection = $y0;

                    // Get z position of the intersection
                    $Z_intersection = $distance;
                    $Z_intersection *= $delta_Z;
                    $Z_intersection /= 1000;
                    $Z_intersection += $relative_Z;

                    // If the ray hits the surface, return this as the minimum distance and the contact surface
                    if ($X_intersection >= $x0 && $X_intersection <= $x1 && $Z_intersection >= $z0 && $Z_intersection <= $z1) find_closest_surface.ray_intersects_with_surface();
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function north() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.North;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[2] and List[5] should have the same values)
            Text.tellraw(@a, "&<italic>Relative X: &<!italic,light_purple,$relative_X>, &<white>x0: &<light_purple,$x0>");

            // If the current position is already in the plane of the surface, check if it is in the surface
            if ($relative_Z = $z0 && $relative_X >= $x0 && $relative_X <= $x1 && $relative_Y >= $y0 && $relative_Y <= $y1) find_closest_surface.ray_already_in_surface();

            // If the current position is before the plane, check if it hits the surface and get the position of that intersection
            if ($relative_Z < $z0) {
                $distance = $z0;
                $distance -= $relative_Z;
                $distance *= 1000;
                $distance /= $delta_Z;
                Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if ($distance < $min_distance_to_surface) {
                    // Get x position of the intersection
                    $X_intersection = $distance;
                    $X_intersection *= $delta_X;
                    $X_intersection /= 1000;
                    $X_intersection += $relative_X;

                    // Get y position of the intersection
                    $Y_intersection = $distance;
                    $Y_intersection *= $delta_Y;
                    $Y_intersection /= 1000;
                    $Y_intersection += $relative_Y;

                    // Get z position of the intersection
                    $Z_intersection = $z0;

                    // If the ray hits the surface, return this as the minimum distance and the contact surface
                    if ($X_intersection >= $x0 && $X_intersection <= $x1 && $Y_intersection >= $y0 && $Y_intersection <= $y1) find_closest_surface.ray_intersects_with_surface();
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function south() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.South;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[2] and List[5] should have the same values)
            Text.tellraw(@a, "&<italic>Relative X: &<!italic,light_purple,$relative_X>, &<white>x0: &<light_purple,$x0>");

            // If the current position is already in the plane of the surface, check if it is in the surface
            if ($relative_Z = $z0 && $relative_X >= $x0 && $relative_X <= $x1 && $relative_Y >= $y0 && $relative_Y <= $y1) find_closest_surface.ray_already_in_surface();

            // If the current position is before the plane, check if it hits the surface and get the position of that intersection
            if ($relative_Z > $z0) {
                $distance = $z0;
                $distance -= $relative_Z;
                $distance *= 1000;
                $distance /= $delta_Z;
                Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if ($distance < $min_distance_to_surface) {
                    // Get x position of the intersection
                    $X_intersection = $distance;
                    $X_intersection *= $delta_X;
                    $X_intersection /= 1000;
                    $X_intersection += $relative_X;

                    // Get y position of the intersection
                    $Y_intersection = $distance;
                    $Y_intersection *= $delta_Y;
                    $Y_intersection /= 1000;
                    $Y_intersection += $relative_Y;

                    // Get z position of the intersection
                    $Z_intersection = $z0;

                    // If the ray hits the surface, return this as the minimum distance and the contact surface
                    if ($X_intersection >= $x0 && $X_intersection <= $x1 && $Y_intersection >= $y0 && $Y_intersection <= $y1) find_closest_surface.ray_intersects_with_surface();
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }

    function ray_already_in_surface() {
        // Name is self-explanatory.

        // @within retina:find_closest_surface/bottom/loop
        // @within retina:find_closest_surface/east/loop
        // @within retina:find_closest_surface/north/loop
        // @within retina:find_closest_surface/south/loop
        // @within retina:find_closest_surface/top/loop
        // @within retina:find_closest_surface/west/loop

        $end = true;
        $closest_cuboid_id = $cuboid_id;
        $min_distance_to_surface = 0;
        data modify storage retina:data ContactSurface set from storage retina:data List[-1];
    }
    function ray_intersects_with_surface() {
        // Establishes the current surface as the first the ray will hit.
        // This function only runs if the ray is closer to this surface than it is to any other surface analysed so far, but there is no guarantee that this is the surface the ray will eventually hit first.
        
        // @within find_closest_surface.bottom()
        // @within find_closest_surface.east()
        // @within find_closest_surface.north()
        // @within find_closest_surface.south()
        // @within find_closest_surface.top.find_intersection()
        // @within find_closest_surface.west()

        $end = true;
        $closest_cuboid_id = $cuboid_id;
        $min_distance_to_surface = $distance;

        data modify storage retina:data ContactSurface set from storage retina:data List[-1];
    }
}

class hitbox {
    function anvil() {}
    function attached_stem() {}
    function bed() {}
    function beetroot() {}
    function brewing_stand() {}
    function button() {}
    function cactus_shaped() {}
    function campfire() {}
    function carpet() {}
    function cauldron() {}
    function chain() {}
    function chest() {}
    function composter() {}
    function conduit() {}
    function cubic() {
        data modify storage retina:data Surfaces.Top set value [[    0,       1000, 0,       1000, 1000, 1000 ]];
        data modify storage retina:data Surfaces.Bottom set value [[ 0,       0,       0,       1000, 0,       1000 ]];
        data modify storage retina:data Surfaces.West set value [[   0,       0,       0,       0,       1000, 1000 ]];
        data modify storage retina:data Surfaces.East set value [[   1000, 0,       0,       1000, 1000, 1000 ]];
        data modify storage retina:data Surfaces.North set value [[  0,       0,       0,       1000, 1000, 0       ]];
        data modify storage retina:data Surfaces.South set value [[  0,       0,       1000, 1000, 1000, 1000 ]];
    }
    function door() {}
    function farmland_shaped() {}
    function fence_gate() {}
    function fence() {}
    function grass_shaped() {}
    function ladder() {}
    function lantern() {}
    function mushroom_shaped() {}
    function pane_shaped() {}
    function pressure_plate() {}
    function rail() {}
    function sapling() {}
    function slab() {
        if (block ~ ~ ~ #minecraft:slabs[type=bottom]) data modify storage retina:data Surfaces set value {Top: [[0, 500,  0, 1000, 500,  1000]], Bottom: [[0, 0, 0, 1000, 0, 1000]], West: [[0, 0, 0, 0, 500, 1000]], East: [[1000, 0, 0, 1000, 500, 1000]], North: [[0, 0, 0, 1000, 500, 0]], South: [[0, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:slabs[type=top]) data modify storage retina:data Surfaces set value    {Top: [[0, 1000, 0, 1000, 1000, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000]], West: [[0, 500, 0, 0, 1000, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000]], North: [[0, 500, 0, 1000, 1000, 0]], South: [[0, 500, 1000, 1000, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:slabs[type=double]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000]], West: [[0, 0, 0, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 1000, 1000]], North: [[0, 0, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 1000, 1000]]}
    }
    function stair() {
        // half=bottom, shape=straight
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=east, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 0, 1000, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 0, 1000, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 0, 500, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 1000, 1000, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=west, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 500, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 500, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [500, 500, 0, 500, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 500, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 500, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=south, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 500, 1000, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 500, 1000, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 500, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 500, 1000, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 500, 1000, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 1000, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=north, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 1000, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 1000, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 500, 1000, 1000, 500]]}

        // half=top, shape=straight
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=east, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 0, 1000, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 0, 1000, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 0, 500, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 0, 1000, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=west, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 500, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 500, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 0, 500, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 500, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 500, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=south, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 500, 1000, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 500, 1000, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 500, 0, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 500, 1000, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 500, 1000, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=north, shape=straight]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 1000, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 1000, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 1000, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 500, 1000, 500, 500]]}

        // half=bottom, shape=inner_left
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=east, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 0, 1000, 1000, 1000], [0, 1000, 0, 500, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 0, 1000, 500, 1000], [0, 500, 0, 500, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 0, 500, 1000, 1000], [0, 500, 0, 0, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 1000], [500, 500, 0, 500, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 0, 1000, 1000, 0], [0, 500, 0, 500, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 1000, 1000, 1000, 1000], [0, 500, 500, 500, 1000, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=west, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 500, 1000, 1000], [500, 1000, 500, 1000, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 500, 500, 1000], [500, 500, 500, 1000, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 1000], [500, 500, 500, 500, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [500, 500, 0, 500, 1000, 1000], [1000, 500, 500, 1000, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 500, 1000, 0], [500, 500, 500, 1000, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 500, 1000, 1000], [500, 500, 1000, 1000, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=south, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 500, 1000, 1000, 1000], [500, 1000, 0, 1000, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 500, 1000, 500, 1000], [500, 500, 0, 1000, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 500, 0, 1000, 1000], [500, 500, 0, 500, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 500, 1000, 1000, 1000], [1000, 500, 0, 1000, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 500, 1000, 1000, 500], [500, 500, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 1000, 1000, 1000], [500, 500, 500, 1000, 1000, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=north, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 1000, 1000, 500], [0, 1000, 500, 500, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 1000, 500, 500], [0, 500, 500, 500, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 500], [0, 500, 500, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 500], [500, 500, 500, 500, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 1000, 1000, 0], [0, 500, 500, 500, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 500, 1000, 1000, 500], [0, 500, 1000, 500, 1000, 1000]]}

        // half=top, shape=inner_left
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=east, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 0, 1000, 500, 1000], [0, 500, 0, 500, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 0, 1000, 0, 1000], [0, 0, 0, 500, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 0, 500, 500, 1000], [0, 0, 0, 0, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 1000], [500, 0, 0, 500, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 0, 1000, 500, 0], [0, 0, 0, 500, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 1000, 1000, 500, 1000], [0, 0, 500, 500, 500, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=west, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 500, 500, 1000], [500, 500, 500, 1000, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 500, 0, 1000], [500, 0, 500, 1000, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 1000], [500, 0, 500, 500, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 0, 500, 500, 1000], [1000, 0, 500, 1000, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 500, 500, 0], [500, 0, 500, 1000, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 500, 500, 1000], [500, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=south, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 500, 1000, 500, 1000], [500, 500, 0, 1000, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 500, 1000, 0, 1000], [500, 0, 0, 1000, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 500, 0, 500, 1000], [500, 0, 0, 500, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 500, 1000, 500, 1000], [1000, 0, 0, 1000, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 500, 1000, 500, 500], [500, 0, 0, 1000, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 1000, 500, 1000], [500, 0, 500, 1000, 500, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=north, shape=inner_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 1000, 500, 500], [0, 500, 500, 500, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 1000, 0, 500], [0, 0, 500, 500, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 500], [0, 0, 500, 0, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 500], [500, 0, 500, 500, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 1000, 500, 0], [0, 0, 500, 500, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 500, 1000, 500, 500], [0, 0, 1000, 500, 500, 1000]]}

        // half=bottom, shape=inner_right
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=east, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 500, 1000, 1000, 1000], [500, 1000, 0, 1000, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 500, 1000, 500, 1000], [500, 500, 0, 1000, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 500, 0, 1000, 1000], [500, 500, 0, 500, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 500, 1000, 1000, 1000], [1000, 500, 0, 1000, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 500, 1000, 1000, 500], [500, 500, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 1000, 1000, 1000], [500, 500, 500, 1000, 1000, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=west, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 1000, 1000, 500], [0, 1000, 500, 500, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 1000, 500, 500], [0, 500, 500, 500, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 500], [0, 500, 500, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 500], [500, 500, 500, 500, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 1000, 1000, 0], [0, 500, 500, 500, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 500, 1000, 1000, 500], [0, 500, 1000, 500, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=south, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 500, 1000, 1000, 1000], [0, 1000, 0, 500, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 500, 1000, 500, 1000], [0, 500, 0, 500, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 500, 0, 1000, 1000], [0, 500, 0, 0, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 500, 1000, 1000, 1000], [500, 500, 0, 500, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 500, 1000, 1000, 500], [0, 500, 0, 500, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 1000, 1000, 1000], [0, 500, 500, 500, 1000, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=north, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 0, 1000, 1000, 1000], [0, 1000, 0, 500, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 0, 1000, 500, 1000], [0, 500, 0, 500, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 0, 500, 1000, 1000], [0, 500, 0, 0, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 1000], [500, 500, 0, 500, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 0, 1000, 1000, 0], [0, 500, 0, 500, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 1000, 1000, 1000, 1000], [0, 500, 500, 500, 1000, 500]]}

        // half=top, shape=inner_right
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=east, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 500, 1000, 500, 1000], [500, 500, 0, 1000, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 500, 1000, 0, 1000], [500, 0, 0, 1000, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 500, 0, 500, 1000], [500, 0, 0, 500, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 500, 1000, 500, 1000], [1000, 0, 0, 1000, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 500, 1000, 500, 500], [500, 0, 0, 1000, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 1000, 500, 1000], [500, 0, 500, 1000, 500, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=west, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 1000, 500, 500], [0, 500, 500, 500, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 1000, 0, 500], [0, 0, 500, 500, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 500], [0, 0, 500, 0, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 500], [500, 0, 500, 500, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 1000, 500, 0], [0, 0, 500, 500, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 500, 1000, 500, 500], [0, 0, 1000, 500, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=south, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 500, 500, 1000], [500, 500, 500, 1000, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 500, 0, 1000], [500, 0, 500, 1000, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 1000], [500, 0, 500, 500, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 0, 500, 500, 1000], [1000, 0, 500, 1000, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 500, 500, 0], [500, 0, 500, 1000, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 500, 500, 1000], [500, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=north, shape=inner_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 0, 1000, 500, 1000], [0, 500, 0, 500, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 0, 1000, 0, 1000], [0, 0, 0, 500, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 0, 500, 500, 1000], [0, 0, 0, 0, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 1000], [500, 0, 0, 500, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 0, 1000, 500, 0], [0, 0, 0, 500, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 1000, 1000, 500, 1000], [0, 0, 500, 500, 500, 500]]}

        // half=bottom, shape=outer_left
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=east, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 0, 1000, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 0, 1000, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 0, 500, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 500, 1000, 1000, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=west, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 500, 500, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 500, 500, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 500, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [500, 500, 500, 500, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 500, 500, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 500, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=south, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 500, 1000, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 500, 1000, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 500, 500, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 500, 1000, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 500, 1000, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 1000, 1000, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=north, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 500, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 500, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [500, 500, 0, 500, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 500, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 500, 500, 1000, 500]]}

        // half=top, shape=outer_left
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=east, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 0, 1000, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 0, 1000, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 0, 500, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 0, 1000, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 500, 1000, 500, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=west, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 500, 500, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 500, 500, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 500, 0, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 500, 500, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 500, 500, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 500, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=south, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 500, 1000, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 500, 1000, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 500, 500, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 500, 1000, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 500, 1000, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=north, shape=outer_left]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 500, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 500, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 0, 500, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 500, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 500, 500, 500, 500]]}

        // half=bottom, shape=outer_right
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=east, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 500, 1000, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 500, 1000, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 500, 500, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 500, 1000, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 500, 1000, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 1000, 1000, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=west, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 0, 500, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 0, 500, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 0, 0, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [500, 500, 0, 500, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 0, 500, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 500, 500, 1000, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=south, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [0, 1000, 500, 500, 1000, 1000]], Bottom: [[0, 0, 0, 1000, 0, 1000], [0, 500, 500, 500, 500, 1000]], West: [[0, 0, 0, 0, 500, 1000], [0, 500, 500, 0, 1000, 1000]], East: [[1000, 0, 0, 1000, 500, 1000], [500, 500, 500, 500, 1000, 1000]], North: [[0, 0, 0, 1000, 500, 0], [0, 500, 500, 500, 1000, 500]], South: [[0, 0, 1000, 1000, 500, 1000], [0, 500, 1000, 500, 1000, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=bottom, facing=north, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 500, 0, 1000, 500, 1000], [500, 1000, 0, 1000, 1000, 500]], Bottom: [[0, 0, 0, 1000, 0, 1000], [500, 500, 0, 1000, 500, 500]], West: [[0, 0, 0, 0, 500, 1000], [500, 500, 0, 500, 1000, 500]], East: [[1000, 0, 0, 1000, 500, 1000], [1000, 500, 0, 1000, 1000, 500]], North: [[0, 0, 0, 1000, 500, 0], [500, 500, 0, 1000, 1000, 0]], South: [[0, 0, 1000, 1000, 500, 1000], [500, 500, 500, 1000, 1000, 500]]}

        // half=top, shape=outer_right
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=east, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 500, 1000, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 500, 1000, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 500, 500, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 500, 1000, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 500, 1000, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 1000, 1000, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=west, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 0, 500, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 0, 500, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 0, 0, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 0, 500, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 0, 500, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 500, 500, 500, 500]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=south, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [0, 500, 500, 500, 500, 1000]], Bottom: [[0, 500, 0, 1000, 500, 1000], [0, 0, 500, 500, 0, 1000]], West: [[0, 500, 0, 0, 1000, 1000], [0, 0, 500, 0, 500, 1000]], East: [[1000, 500, 0, 1000, 1000, 1000], [500, 0, 500, 500, 500, 1000]], North: [[0, 500, 0, 1000, 1000, 0], [0, 0, 500, 500, 500, 500]], South: [[0, 500, 1000, 1000, 1000, 1000], [0, 0, 1000, 500, 500, 1000]]}
        if (block ~ ~ ~ #minecraft:stairs[half=top, facing=north, shape=outer_right]) data modify storage retina:data Surfaces set value {Top: [[0, 1000, 0, 1000, 1000, 1000], [500, 500, 0, 1000, 500, 500]], Bottom: [[0, 500, 0, 1000, 500, 1000], [500, 0, 0, 1000, 0, 500]], West: [[0, 500, 0, 0, 1000, 1000], [500, 0, 0, 500, 500, 500]], East: [[1000, 500, 0, 1000, 1000, 1000], [1000, 0, 0, 1000, 500, 500]], North: [[0, 500, 0, 1000, 1000, 0], [500, 0, 0, 1000, 500, 0]], South: [[0, 500, 1000, 1000, 1000, 1000], [500, 0, 500, 1000, 500, 500]]}

    }
    function standing_sign_or_banner() {}
    function sugar_cane_like() {}
    function trapdoor() {}
    function vertical_torch() {}
    function wall_sign() {}
    function wall_torch() {}
    function wall() {}
}