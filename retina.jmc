import "math";

new tags.blocks(fire) {
    "values": ["minecraft:fire", "minecraft:soul_fire"]
}
new tags.blocks(fluid) {
    "values": ["minecraft:water", "minecraft:lava"]
}
new tags.blocks(passable) {
    "values": [
        "minecraft:air",
        "minecraft:cave_air",
        "minecraft:void_air"
	]
}

summon minecraft:marker 0 0 0 {Tags:["retina.height","retina.ignore"]};

class traverse {
    function setup() {

        $input_pitch = data get entity @s Rotation[1] 10;
        $input_yaw = data get entity @s Rotation[0] 10;
        Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
        math.gimbal_to_vec();
        Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.x>, &<$output_vec3.y>, &<$output_vec3.z>]");

        execute anchored eyes run tp @e[type=marker,tag=retina.height,limit=1] ~ ~ ~;
        $x = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[0] 1000;
        $y = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[1] 1000;
        $z = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[2] 1000;
        tp @e[type=marker,tag=retina.height,limit=1] 0 0 0;

        Hardcode.repeatList(
            "comp",
            () => {
                if ($output_vec3.comp < 0) $sign_comp = -1;
                if ($output_vec3.comp >= 0) $sign_comp = 1;

                $delta_comp = 1000000;
                $delta_comp /= $output_vec3.comp;
                $delta_comp /= $sign_comp;

                $distance_comp = $sign_comp;
                $distance_comp *= -1;
                $distance_comp *= $comp;
                $distance_comp %= 1000;
                $distance_comp *= $delta_comp;
                $distance_comp /= 1000;

                if ($output_vec3.comp == 0) $delta_comp = 2147483647;
                if ($output_vec3.comp == 0) $distance_comp = 2147483647;

                $visual_comp = $comp;
                $visual_comp /= 1000;
            },
            ["x", "y", "z"]
        );
        Text.tellraw(@a, "Origin: &<yellow>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");

        $step = 0;
        $end = 0;
        traverse.loop();
    }
    function loop() {
        // Find nearest axis
        $shortest_distance = $distance_x;
        $shortest_distance < $distance_y;
        $shortest_distance < $distance_z;
        if ($shortest_distance = $distance_z) $nearest_axis = 2;
        if ($shortest_distance = $distance_y) $nearest_axis = 1;
        if ($shortest_distance = $distance_x) $nearest_axis = 0;
        
        // Process data based on nearest axis
        if ($nearest_axis = 0 && $step < 300 && $end = 0) traverse.x();
        if ($nearest_axis = 1 && $step < 300 && $end = 0) traverse.y();
        if ($nearest_axis = 2 && $step < 300 && $end = 0) traverse.z();

    }
    function x() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_x>, &<$distance_y>, &<$distance_z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>X");
        $distance_x += $delta_x;
        if ($end = 0) {
            $visual_x += $sign_x;
            if ($sign_x = -1) execute positioned ~-1 ~0 ~0 run check.main();
            if ($sign_x = 1) execute positioned ~1 ~0 ~0 run check.main();
        }
    }
    function y() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_x>, &<$distance_y>, &<$distance_z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Y");
        $distance_y += $delta_y;
        if ($end = 0) {
            $visual_y += $sign_y;
            if ($sign_y = -1) execute positioned ~0 ~-1 ~0 run check.main();
            if ($sign_y = 1) execute positioned ~0 ~1 ~0 run check.main();
        }
    }
    function z() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_x>, &<$distance_y>, &<$distance_z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Z");
        $distance_z += $delta_z;
        if ($end = 0) {
            $visual_z += $sign_z;
            if ($sign_z = -1) execute positioned ~0 ~0 ~-1 run check.main();
            if ($sign_z = 1) execute positioned ~0 ~0 ~1 run check.main();
        }
    }
}

class check {
    function main() {
        $step++;
        $end = false;

        check.block.main();
        if ($end) check.collision.main();
        
        if ($step >= 300) $end = 1;
        if ($step >= 300) Text.tellraw(@a, "&<italic, light_purple>Failed to find anything within &<$step> blocks. End coordinates: &<bold>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");
        if ($end == 0) traverse.loop();
    }
    class block {
        function main() {
            if (!block ~ ~ ~ #retina:passable) $end = true;
            if ($end) {
                Text.tellraw(@a, "&<bold, underlined, gray>Block has been hit! Coordinates: &<blue>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");
                if ($debug_gold = 1) setblock ~ ~ ~ gold_block;
            }
            if (!$end) {
                Text.tellraw(@a, "&<italic, white>No block... Coordinates: &<blue>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");
            }
        }
    }
    class collision {
        function main() {
            if ($nearest_axis = 0) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>X");
            if ($nearest_axis = 1) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>Y");
            if ($nearest_axis = 2) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>Z");
        }
    }
}