import "math";

new tags.blocks(airs) {
    "values": [
        "minecraft:air",
        "minecraft:cave_air",
        "minecraft:void_air"
	]
}

new tags.blocks(anvil) {
    "values": ["#minecraft:anvil"]
}
new tags.blocks(attached_stem) {
	"values": [
		"minecraft:attached_melon_stem",
		"minecraft:attached_pumpkin_stem"
	]
}
new tags.blocks(bed) {
	"values": ["#minecraft:beds"]
}
new tags.blocks(beetroot) {
	"values": ["minecraft:beetroots"]
}
new tags.blocks(brewing_stand) {
	"values": ["minecraft:brewing_stand"]
}
new tags.blocks(button) {
	"values": ["minecraft:buttons"]
}
new tags.blocks(cactus_shaped) {
    "values": [
		"minecraft:cactus",
		"minecraft:dragon_egg"
	]
}
new tags.blocks(campfire) {
    "values": ["#minecraft:campfires"]
}
new tags.blocks(carpet) {
    "values": [
        "#minecraft:wool_carpets",
        "minecraft:moss_carpet"
    ]
}
new tags.blocks(cauldron) {
    "values": ["#minecraft:cauldrons"]
}
new tags.blocks(chain) {
    "values": ["minecraft:chain"]
}
new tags.blocks(chests) {
    "values": [
		"minecraft:chest",
		"minecraft:ender_chest",
		"minecraft:trapped_chest"
	]
}
new tags.blocks(composter) {
    "values": ["minecraft:composter"]
}
new tags.blocks(conduit) {
    "values": ["minecraft:conduit"]
}
new tags.blocks(door) {
    "values": ["#minecraft:doors"]
}
new tags.blocks(farmland_shaped) {
    "values": [
        "minecraft:farmland",
        "minecraft:dirt_path"
    ]
}
new tags.blocks(fence) {
    "values": ["#minecraft:fences"]
}
new tags.blocks(fence_gate) {
    "values": ["#minecraft:fence_gates"]
}
new tags.blocks(grass_shaped) {
    "values": [
		"minecraft:grass",
		"minecraft:fern",
		"minecraft:dead_bush",
		"minecraft:warped_roots",
		"minecraft:crimson_roots",
		"minecraft:small_dripleaf"
	]
}
new tags.blocks(ladder) {
    "values": ["minecraft:ladder"]
}
new tags.blocks(lantern) {
    "values": [
        "minecraft:lantern",
        "minecraft:soul_lantern"
    ]
}
new tags.blocks(mushroom_shaped) {
	"values": [
		"minecraft:brown_mushroom",
		"minecraft:red_mushroom",
		"minecraft:flower_pot",
		"minecraft:potted_oak_sapling",
		"minecraft:potted_spruce_sapling",
		"minecraft:potted_birch_sapling",
		"minecraft:potted_jungle_sapling",
		"minecraft:potted_acacia_sapling",
		"minecraft:potted_dark_oak_sapling",
		"minecraft:potted_fern",
		"minecraft:potted_dandelion",
		"minecraft:potted_poppy",
		"minecraft:potted_blue_orchid",
		"minecraft:potted_allium",
		"minecraft:potted_azure_bluet",
		"minecraft:potted_red_tulip",
		"minecraft:potted_orange_tulip",
		"minecraft:potted_white_tulip",
		"minecraft:potted_pink_tulip",
		"minecraft:potted_oxeye_daisy",
		"minecraft:potted_cornflower",
		"minecraft:potted_lily_of_the_valley",
		"minecraft:potted_wither_rose",
		"minecraft:potted_red_mushroom",
		"minecraft:potted_brown_mushroom",
		"minecraft:potted_dead_bush",
		"minecraft:potted_cactus",
		"minecraft:potted_bamboo",
		"minecraft:potted_crimson_fungus",
		"minecraft:potted_warped_fungus",
		"minecraft:potted_crimson_roots",
		"minecraft:potted_warped_roots",
		"minecraft:potted_azalea_bush",
		"minecraft:potted_flowering_azalea_bush"
	]
}
new tags.blocks(pane_shaped) {
	"values": [
		"minecraft:iron_bars",
		"minecraft:glass_pane",
		"minecraft:white_stained_glass_pane",
		"minecraft:orange_stained_glass_pane",
		"minecraft:magenta_stained_glass_pane",
		"minecraft:light_blue_stained_glass_pane",
		"minecraft:yellow_stained_glass_pane",
		"minecraft:lime_stained_glass_pane",
		"minecraft:pink_stained_glass_pane",
		"minecraft:gray_stained_glass_pane",
		"minecraft:light_gray_stained_glass_pane",
		"minecraft:cyan_stained_glass_pane",
		"minecraft:purple_stained_glass_pane",
		"minecraft:blue_stained_glass_pane",
		"minecraft:brown_stained_glass_pane",
		"minecraft:green_stained_glass_pane",
		"minecraft:red_stained_glass_pane",
		"minecraft:black_stained_glass_pane"
	]
}
new tags.blocks(pressure_plate) {
    "values": ["#minecraft:pressure_plates"]
}
new tags.blocks(rail) {
	"values": [
        "minecraft:rail",
		"minecraft:activator_rail",
		"minecraft:detector_rail",
		"minecraft:powered_rail"
	]
}
new tags.blocks(sapling) {
    "values": ["#minecraft:saplings"]
}
new tags.blocks(slab) {
    "values": ["#minecraft:slabs"]
}
new tags.blocks(sugar_cane_like) {
	"values": [
		"minecraft:sugar_cane",
		"minecraft:tall_seagrass"
	]
}
new tags.blocks(stair) {
    "values": ["#minecraft:stairs"]
}
new tags.blocks(standing_sign_or_banner) {
    "values": [
		"#minecraft:standing_signs",
		"minecraft:white_banner",
		"minecraft:orange_banner",
		"minecraft:magenta_banner",
		"minecraft:light_blue_banner",
		"minecraft:yellow_banner",
		"minecraft:lime_banner",
		"minecraft:pink_banner",
		"minecraft:gray_banner",
		"minecraft:light_gray_banner",
		"minecraft:cyan_banner",
		"minecraft:purple_banner",
		"minecraft:blue_banner",
		"minecraft:brown_banner",
		"minecraft:green_banner",
		"minecraft:red_banner",
		"minecraft:black_banner",
		"minecraft:twisting_vines_plant"
	]
}
new tags.blocks(trapdoor) {
    "values": ["#minecraft:trapdoors"]
}
new tags.blocks(vertical_torch) {
	"values": [
		"minecraft:torch",
		"minecraft:redstone_torch",
		"minecraft:soul_torch"
	]
}
new tags.blocks(wall) {
    "values": ["#minecraft:walls"]
}
new tags.blocks(wall_sign) {
    "values": ["#minecraft:wall_signs"]
}
new tags.blocks(wall_torch) {
	"values": [
		"minecraft:wall_torch",
		"minecraft:redstone_wall_torch",
		"minecraft:soul_wall_torch"
	]
}

//summon minecraft:marker 0 0 0 {Tags:["retina.height","retina.ignore"]};

class traverse {
    function setup() {

        $input_pitch = data get entity @s Rotation[1] 10;
        $input_yaw = data get entity @s Rotation[0] 10;
        Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
        math.gimbal_to_vec();
        Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.x>, &<$output_vec3.y>, &<$output_vec3.z>]");

        execute anchored eyes run summon minecraft:marker ^ ^ ^ {Tags:["retina.height"]};
        $x = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[0] 1000;
        $y = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[1] 1000;
        //$y += 1620;
        $z = data get entity @e[type=marker,tag=retina.height,limit=1] Pos[2] 1000;
        kill @e[type=marker,tag=retina.height,limit=1];

        Hardcode.repeatList(
            "comp",
            () => {
                if ($output_vec3.comp < 0) $sign_comp = -1;
                if ($output_vec3.comp >= 0) $sign_comp = 1;

                $delta_comp = 1000000;
                $delta_comp /= $output_vec3.comp;
                $delta_comp /= $sign_comp;

                $distance_comp = $comp;
                $distance_comp *= $sign_comp;
                $distance_comp *= -1;
                $distance_comp %= 1000;
                $distance_comp *= $delta_comp;
                $distance_comp /= 1000;

                if ($output_vec3.comp == 0) $delta_comp = 2147483647;
                if ($output_vec3.comp == 0) $distance_comp = 2147483647;

                $visual_comp = $comp;
                $visual_comp /= 1000;
            },
            ["x", "y", "z"]
        );
        Text.tellraw(@a, "Origin: &<yellow>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");

        $step = 0;
        $end = 0;
        execute positioned ~ ~1.62 ~ run traverse.loop();
    }
    function loop() {
        // Find nearest axis
        $shortest_distance = $distance_x;
        $shortest_distance < $distance_y;
        $shortest_distance < $distance_z;
        if ($shortest_distance = $distance_z) $nearest_axis = 2;
        if ($shortest_distance = $distance_y) $nearest_axis = 1;
        if ($shortest_distance = $distance_x) $nearest_axis = 0;
        
        // Process data based on nearest axis
        if ($nearest_axis = 0 && $step < 300 && $end = 0) traverse.x();
        if ($nearest_axis = 1 && $step < 300 && $end = 0) traverse.y();
        if ($nearest_axis = 2 && $step < 300 && $end = 0) traverse.z();

    }
    function x() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_x>, &<$distance_y>, &<$distance_z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>X");
        $distance_x += $delta_x;
        if ($end = 0) {
            $visual_x += $sign_x;
            if ($sign_x = -1) execute positioned ~-1 ~0 ~0 run check.main();
            if ($sign_x = 1) execute positioned ~1 ~0 ~0 run check.main();
        }
    }
    function y() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_x>, &<$distance_y>, &<$distance_z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Y");
        $distance_y += $delta_y;
        if ($end = 0) {
            $visual_y += $sign_y;
            if ($sign_y = -1) execute positioned ~0 ~-1 ~0 run check.main();
            if ($sign_y = 1) execute positioned ~0 ~1 ~0 run check.main();
        }
    }
    function z() {
        Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_x>, &<$distance_y>, &<$distance_z>]");
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Z");
        $distance_z += $delta_z;
        if ($end = 0) {
            $visual_z += $sign_z;
            if ($sign_z = -1) execute positioned ~0 ~0 ~-1 run check.main();
            if ($sign_z = 1) execute positioned ~0 ~0 ~1 run check.main();
        }
    }
}

class check {
    function main() {
        $step++;
        $end = false;

        check.block.main();
        if ($end) check.debug();
        
        if ($step >= 300) $end = 1;
        if ($step >= 300) Text.tellraw(@a, "&<italic, light_purple>Failed to find anything within &<$step> blocks. End coordinates: &<bold>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");
        if ($end == 0) traverse.loop();
    }
    class block {
        function main() {
            if (!block ~ ~ ~ #retina:airs) check.block.get_hitbox();
            if ($end) {
                Text.tellraw(@a, "&<bold, underlined, gray>Block has been hit! Coordinates: &<blue>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");
                if ($debug_gold = 1) setblock ~ ~ ~ gold_block;
            }
            if (!$end) {
                Text.tellraw(@a, "&<italic, white>No block... Coordinates: &<blue>[&<$visual_x>, &<$visual_y>, &<$visual_z>]");
            }
        }
        function get_hitbox() {
            $block_found = false;
            Hardcode.repeatList(
                "[shape]",
                () => {
                    $block.[shape] = false;
                    if (!$block_found) $block.[shape] ?= execute if block ~ ~ ~ #retina:[shape];
                    $block_found = $block.[shape];
                    if ($block.[shape]) hitbox.[shape]();
                },
                ["anvil"]
            );
            if (block ~ ~ ~ minecraft:honey_block && $honey_exception) {
                $block_found = true;
                hitbox.chest();
            }
            if (!$block_found) hitbox.cubic(); // if it doesn't match any special hitbox, assume it's a 1x1x1 cube.
        }
    }
    function debug() {
        if ($nearest_axis = 0) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>X");
        if ($nearest_axis = 1) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>Y");
        if ($nearest_axis = 2) Text.tellraw(@a, "&<bold, white>Block hit direction: &<bold, dark_purple>Z");
    }
}

class hitbox {
    function anvil() {}
    function chest() {}
    function cubic() {
        $end = true;
    }
}