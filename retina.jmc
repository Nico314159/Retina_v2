import "math";

new tags.blocks(fire) {
    "values": ["minecraft:fire", "minecraft:soul_fire"]
}
new tags.blocks(fluid) {
    "values": ["minecraft:water", "minecraft:lava"]
}
new tags.blocks(passable) {
    "values": [
        "#minecraft:replaceable_plants",    
		"#minecraft:small_flowers",
		"#minecraft:tall_flowers",
		"#minecraft:crops",
		"minecraft:grass",
		"minecraft:fern",
		"minecraft:dead_bush",
		"minecraft:warped_roots",
		"minecraft:crimson_roots",
		"minecraft:small_dripleaf",
		"minecraft:sugar_cane",
		"minecraft:tall_seagrass",
		"minecraft:cobweb"
	]
}

class traverse {
    function setup() {
        

        $input_pitch = data get entity @s Rotation[1] 10;
        $input_yaw = data get entity @s Rotation[0] 10;
        Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
        math.gimbal_to_vec();
        Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.x>, &<$output_vec3.y>, &<$output_vec3.z>]");

        $x = data get entity @s Pos[0];
        $y = data get entity @s Pos[1];
        $z = data get entity @s Pos[2];
        Text.tellraw(@a, "Origin: &<yellow>[&<$x>, &<$y>, &<$z>]");

        $delta_x = 1000000;
        $delta_y = 1000000;
        $delta_z = 1000000;
        $delta_x /= $output_vec3.x;
        $delta_y /= $output_vec3.y;
        $delta_z /= $output_vec3.z;
        if ($output_vec3.x == 0) $delta_x = 2147483647;
        if ($output_vec3.y == 0) $delta_y = 2147483647;
        if ($output_vec3.z == 0) $delta_z = 2147483647;
        Text.tellraw(@a, "Distances to each block: &<green>[&<$delta_x>, &<$delta_y>, &<$delta_z>]");

        $distance_x = $delta_x;
        $distance_y = $delta_y;
        $distance_z = $delta_z;
        traverse.loop();
    }
    function loop() {
        // Stop if motion ceases
        if ($distance_x = 2147483647 && $distance_y = 2147483647 && $distance_z = 2147483647) $motion_end = true;
        
        // Find nearest axis
        $shortest_distance = $distance_x;
        $shortest_distance < $distance_y;
        $shortest_distance < $distance_z;
        if ($shortest_distance = $distance_z) $nearest_axis = 2;
        if ($shortest_distance = $distance_y) $nearest_axis = 1;
        if ($shortest_distance = $distance_x) $nearest_axis = 0;
        
        // Process data based on nearest axis
        switch ($nearest_axis) {
            case 0: traverse.x();
            case 1: traverse.y();
            case 2: traverse.z();
        }
        
        if ($motion_end = 0) traverse.loop();
        if ($motion_end) particle minecraft:flame ~ ~ ~;
    }
    function x() {
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>X");
        $distance_x += $delta_x;
        if ($motion_end = 0) {
            $motion_x += 1000;
            $x += $sign_x;
            if ($sign_x = -1) execute  positioned ~-1 ~0 ~0 run check.main();
            if ($sign_x = 1) execute positioned ~1 ~0 ~0 run check.main();
        }
    }
    function y() {
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Y");
        $distance_y += $delta_y;
        if ($motion_end = 0) {
            $motion_y += 1000;
            $y += $sign_y;
            if ($sign_y = -1) execute positioned ~0 ~-1 ~0 run check.main();
            if ($sign_y = 1) execute positioned ~0 ~1 ~0 run check.main();
        }
    }
    function z() {
        Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Z");
        $distance_z += $delta_z;
        if ($motion_end = 0) {
            $motion_z += 1000;
            $z += $sign_z;
            if ($sign_z = -1) execute positioned ~0 ~0 ~-1 run check.main();
            if ($sign_z = 1) execute positioned ~0 ~0 ~1 run check.main();
        }
    }
}

class check {
    function main() {
        $collision = false;
        $is_fluid = false;
        $is_fire = false;

        check.block.main();

        // Adjust motion if inside block
        if (!$collision_boolean && $fluid) $motion_fluid_boolean = true;
        if (!$collision_boolean && $fire) $motion_fire_boolean = true;
        if ($collision_boolean) check.collision.main();
        if (!$collision_boolean) traverse.loop();
    }
    class block {
        function main() {
            $boolean = false;
            if ($boolean <= 0 && !block ~ ~ ~ #retina:passable) $boolean = true;
            if (block ~ ~ ~ #retina:fluid) $is_fluid = true;
            if (block ~ ~ ~ #retina:fire) $is_fire = true;
            if ($boolean) {
                Text.tellraw(@a, "&<bold, underlined, gray>Block has been hit! Coordinates: &<blue>[&<$x>, &<$y>, &<$z>]");
            }
            if (!$boolean) {
                Text.tellraw(@a, "&<italic, white>No block... Coordinates: &<blue>[&<$x>, &<$y>, &<$z>]");
            }
            $collision_boolean = $boolean;
        }
    }
    class collision {
        function main() {
            switch ($nearest_axis) {
                case 0: check.collision.x();
                case 1: check.collision.y();
                case 2: check.collision.z();
            }
        }
        function x() {
            Text.tellraw(@a, "&<bold, white>Block hit direction: X&<bold, light_purple>");
            $collision_x = true; // Set collision axis
            $distance_x -= 1001; // Kick back values
            $motion_end = true; // Halt
        }
        function y() {
            Text.tellraw(@a, "&<bold, white>Block hit direction: Y&<bold, light_purple>");
            $collision_y = true; // Set collision axis
            $distance_y -= 1001; // Kick back values
            $motion_end = true; // Halt
        }
        function z() {
            Text.tellraw(@a, "&<bold, white>Block hit direction: Z&<bold, light_purple>");
            $collision_z = true; // Set collision axis
            $distance_z -= 1001; // Kick back values
            $motion_end = true; // Halt
        }
    }
}