import "math";
import "tags";

//summon minecraft:marker 0 0 0 {Tags:["retina.height","retina.ignore"]};
$single_call = true;
$overflow_risk = MAX_INT;
$overflow_risk /= SCALE;
Scoreboard.add(retina.id, dummy);
Scoreboard.add(retina.hit, dummy);
input:: += {HorizontalCount: 1b, VerticalCount: 1b, CenteredCount: 0b, SpreadFactor: [100, 100], EndpointEntity: 0b};
if (!data storage retina:input MaxRecursionDepth) {
    input:: += {MaxRecursionDepth: 50};
}
if (!data storage retina:input TargetBlocks) {
    input:: += {TargetBlocks: true};
}
if (!data storage retina:input TargetEntities) {
    input:: += {TargetEntities: true};
}
output:: += {ContactCoordinates: [], ContactSurface: [], Distance: 0.0d, HitFace: "", PlacingPosition: [], Target: "", TargetedBlock: []};

class shared {
    @lazy
    function reset_output() {
        output::Target = "NONE";
        output::Distance = input::MaxRecursionDepth;
        output::HitEntityHead = false;
        output::TargetedBlock.del();
        output::TargetedEntity.del();
        output::PlacingPosition.del();
        output::ContactSurface.del();
        output::ContactCoordinates.del();
        output::HitFace.del();
    }
    @lazy 
    function guard() {
        // guard condition
        Hardcode.repeatList(
            "[i]",
            () => {
                $int_[i] = $overflow_check_[i]; //use scoreboard got just above to avoid getting player data since it is very expensive
                $test_[i] = $int_[i];
                $test_[i] /= $overflow_risk;
                if (!$test_[i] matches -1..0) return run {
                    Text.tellraw(@a, "&<dark_red>[Error] &<red>Raycast [i] coordinate of &<$int_[i]> is out of range (-&<$overflow_risk>, &<$overflow_risk>)");
                }
            },
            ["X", "Z"] // not worried about Y since that's never gonna be high enough to overflow
        );
    }
    @lazy
    function reset_flags() {
        $block_distance = $entity_distance = MAX_INT;
		$hit_block = $hit_entity = $contact = false;
        $max_depth = input::MaxRecursionDepth;
        $max_depth *= $max_depth;
    }
    @lazy
    function calculate() {
        Hardcode.repeatList(
            "[i]",
            () => {
                $origin_[i] = $[i];
                $frac_origin_[i] = $[i];
                $frac_origin_[i] %= SCALE;
                $step_[i] = 0;

                if ($output_vec3.[i] < 0) $sign_[i] = -1;
                if ($output_vec3.[i] >= 0) $sign_[i] = 1;

                $delta_[i] = EVAL(SCALE ** 2);
                $delta_[i] /= $output_vec3.[i];
                $delta_[i] /= $sign_[i];

                $distance_[i] = $[i];
                $distance_[i] *= $sign_[i];
                $distance_[i] *= -1;
                $distance_[i] %= SCALE;
                $distance_[i] *= $delta_[i];
                $distance_[i] /= SCALE;

                if ($output_vec3.[i] == 0) {
                    $delta_[i] = $distance_[i] = MAX_INT;
                }

                $int_[i] = $[i];
                $int_[i] /= SCALE;
            },
            ["X", "Y", "Z"]
        );
        if ($debug_messages) Text.tellraw(@a, "Origin: &<yellow>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
    }
    @lazy
    function handle_hit() {
        if ($hit_block) storage.block();
        if ($hit_entity) storage.entity();
        execute run function #retina:on_hit;
    }
}


class traverse {
    function setup() {
        shared.reset_output();
        
        $overflow_check_X = @s::Pos[0];
        $overflow_check_Z = @s::Pos[2];

        shared.guard();
        
        shared.reset_flags();

        tag @s add retina.executing;
        if ($single_call) {
            tag @e remove retina.target;
            scoreboard players reset * retina.hit;
            kill @e[type=marker,tag=retina.endpoint];
            $input_pitch = @s::Rotation[1] * 10;
            $input_yaw = @s::Rotation[0] * 10;
            if ($debug_messages) Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
            Math.gimbal_to_vec();
            if ($debug_messages) Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.X>, &<$output_vec3.Y>, &<$output_vec3.Z>]");
        }

        execute anchored eyes positioned ^ ^ ^ summon minecraft:marker run {
            $X = @s::Pos[0] * SCALE;
            $Y = @s::Pos[1] * SCALE;
            $Z = @s::Pos[2] * SCALE;
            kill @s;
        }

        shared.calculate();

        $step = 0;
        $offset_Y = @s::Pos[1] * EVAL(-SCALE);
        $offset_Y += $Y;
        data::offset_Y = EVAL(1 / SCALE) * (double) $offset_Y;
        
        execute run {
            $ execute positioned ~ ~$(offset_Y) ~ run traverse.loop();
        } with data::;

        shared.handle_hit();
        tag @s remove retina.executing;
    }

    function setup_no_entity() {
        // this function can be run without an entity as context. just run it with already the correct position and direction context
        // set OverrideExecutingEntity to true to prevent the function to exclude the entity in the start block from being selected
        // set ExpandEntityHitboxes to the amount of blocks (double) to expand the hibox (0 to 1)

        shared.reset_output();
        
        shared.reset_flags();

        //override executing entity
        $override_executing = input::OverrideExecutingEntity;
        input::OverrideExecutingEntity.del();
        //expand hit boxes
        if (data storage retina:input ExpandEntityHitboxes) {
            $expand_entity_hitboxes = input::ExpandEntityHitboxes * SCALE;
        }
        if ($expand_entity_hitboxes == 0) {
            scoreboard players reset $expand_entity_hitboxes retina.__variable__;
        }
        input::ExpandEntityHitboxes.del();

        if (!$override_executing) {
            execute positioned ~-0.5 ~-0.5 ~-0.5 run tag @e[dx=0] add retina.executing;
        }

        execute unless data storage retina:input SetupContext summon minecraft:marker run {
            tag @e remove retina.target;
            scoreboard players reset * retina.hit;
            kill @e[type=marker,tag=retina.endpoint];

            tp @s ~ ~ ~ ~ ~;
            input::SetupContext = @s::{}; //use storage cause it is more efficent then getting data from entity
            kill @s;
        }

        $input_pitch = input::SetupContext.Rotation[1] * 10;
        $input_yaw = input::SetupContext.Rotation[0] * 10;

        $X = input::SetupContext.Pos[0] * SCALE;
        $Y = input::SetupContext.Pos[1] * SCALE;
        $Z = input::SetupContext.Pos[2] * SCALE;

        $overflow_check_X = input::SetupContext.Pos[0] * 1;
        $overflow_check_Z = input::SetupContext.Pos[2] * 1;
        shared.guard();

        if ($debug_messages) Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
        Math.gimbal_to_vec();
        if ($debug_messages) Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.X>, &<$output_vec3.Y>, &<$output_vec3.Z>]");

        shared.calculate();

        $step = 0;
        traverse.loop(); //deleted offset stuff cause we are running the function in the correct context already

        shared.handle_hit();

        if (!$override_executing) {
            execute positioned ~-0.5 ~-0.5 ~-0.5 run tag @e[dx=0] remove retina.executing;
        }
        
        // reset special scores
        scoreboard players reset $expand_entity_hitboxes retina.__variable__;
        scoreboard players reset $override_executing retina.__variable__;
    }

    function loop() {
        // Find nearest axis
        $shortest_distance = $distance_X;
        $shortest_distance < $distance_Y;
        $shortest_distance < $distance_Z;
        if ($shortest_distance = $distance_Z) $nearest_axis = 2;
        if ($shortest_distance = $distance_Y) $nearest_axis = 1;
        if ($shortest_distance = $distance_X) $nearest_axis = 0;
        
        $prev_X = $int_X;
        $prev_Y = $int_Y;
        $prev_Z = $int_Z;

        if ($debug_messages == 2) particle crit;

        // Process data based on nearest axis
        if ($nearest_axis = 0 && no_break) traverse.x();
        if ($nearest_axis = 1 && no_break) traverse.y();
        if ($nearest_axis = 2 && no_break) traverse.z();
    }
    function x() {
        if ($debug_messages) expand {
            Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
            Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>X");
        }
        $distance_X += $delta_X;
        $step_X += $sign_X;
        $int_X += $sign_X;

        if ($sign_X = -1) execute positioned ~-1 ~0 ~0 run check.main();
        if ($sign_X = 1) execute positioned ~1 ~0 ~0 run check.main();
    }
    function y() {
        if ($debug_messages) expand {
            Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
            Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Y");
        }
        $distance_Y += $delta_Y;
        $step_Y += $sign_Y;
        $int_Y += $sign_Y;

        if ($sign_Y = -1) execute positioned ~0 ~-1 ~0 run check.main();
        if ($sign_Y = 1) execute positioned ~0 ~1 ~0 run check.main();
    }
    function z() {
        if ($debug_messages) expand {
            Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
            Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Z");
        }
        $distance_Z += $delta_Z;
        $step_Z += $sign_Z;
        $int_Z += $sign_Z;

        if ($sign_Z = -1) execute positioned ~0 ~0 ~-1 run check.main();
        if ($sign_Z = 1) execute positioned ~0 ~0 ~1 run check.main();
    }
    function multicast() {
        $horizontal_count = input::HorizontalCount * 10;
        $vertical_count = input::VerticalCount * 10;
        $centered_count = input::CenteredCount * 1;

        // input validation
        if ($horizontal_count <= 0) return run {
            Text.tellraw(@a, "&<dark_red>[Error] &<red>HorizontalCount storage has invalid value of &<$horizontal_count>");
        }
        if ($vertical_count <= 0) return run {
            Text.tellraw(@a, "&<dark_red>[Error] &<red>VerticalCount storage has invalid value of &<$vertical_count>");
        } 
        if ($centered_count < 0) return run {
            Text.tellraw(@a, "&<dark_red>[Error] &<red>CenteredCount storage has invalid value of &<$centered_count>");
        }

        $spread_least = input::SpreadFactor[0];
        $spread_most = input::SpreadFactor[1];

        $single_call = false;
        tag @e remove retina.target;
        scoreboard players reset * retina.hit;
        kill @e[type=marker,tag=retina.endpoint];
        $input_pitch = @s::Rotation[1] * 10;
        $input_yaw = @s::Rotation[0] * 10;
        Math.gimbal_to_matrix();
        for ($i = 0; $i < $horizontal_count; $i += 10) { 
            for ($j = 0; $j < $vertical_count; $j += 10) {
                Math.Sway_Heave_Surge.find();
                Math.Sway_Heave_Surge.apply();
                traverse.setup();
            } 
        }

        for ($k = 0; $k < $centered_count; $k++) {traverse.setup();}
        $single_call = true;
    }
}   


class check {
    function main() {
        $distance_traveled_squared_X = $step_X;
        $distance_traveled_squared_X *= $step_X;
        $distance_traveled_squared_Y = $step_Y;
        $distance_traveled_squared_Y *= $step_Y;
        $distance_traveled_squared_Z = $step_Z;
        $distance_traveled_squared_Z *= $step_Z;
        $step = $distance_traveled_squared_X;
        $step += $distance_traveled_squared_Y; 
        $step += $distance_traveled_squared_Z;

        $check_for_head = false;
        if (data storage retina:input {TargetBlocks: true}) {
            check.block.main();
        }
        if (data storage retina:input {TargetEntities: true}) {
            check.entity.main();
        }

        if ($step >= $max_depth && $debug_messages) {
            Text.tellraw(@a, "&<italic, light_purple>Failed to find anything within &<$step> blocks. End coordinates: &<bold>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
        }
        if (no_break) {traverse.loop();}
    }
    class block {
        function main() {
            if (block ~ ~ ~ #retina:airs) return 0;
            check.block.found();
            if (!$hit_block) return run {
                if ($debug_messages) {
                    Text.tellraw(@a, "&<italic, white>No block... Coordinates: &<blue>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
                }
            } 
            
            if ($debug_messages) {
                Text.tellraw(@a, "&<bold, underlined, gray>Block has been hit! Coordinates: &<blue>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
            }
            if ($debug_gold) setblock ~ ~ ~ gold_block;
            // if ($end_particle) particle minecraft:end_rod ~ ~ ~ 0 0 0 0 1 force @a;
        }
        function found() {
            // Clear residual data from `Surfaces`
            data::Surfaces.del();
            data::Surfaces = {Top:[],Bottom:[],West:[],East:[],North:[],South:[]};
            check.block.get_hitbox();

            // See if the ray hits any surface
            if (data storage retina:data Surfaces) find_closest_surface.main(); 
            if ($contact) $block_distance = $min_distance_to_surface;
            $hit_block = $contact;
        }
        function get_hitbox() {
            Hardcode.repeatList(
                "[shape]",
                () => { 
                    if (block ~ ~ ~ #retina:[shape] && !$ignore_[shape]) {
                        return run hitbox.[shape]();
                    }
                },
                ["amethyst", "anvil", "attached_stem", "azalea", "bed", "bell", "berries", "big_dripleaf", "big_dripleaf_stem", "brewing_stand", "button", 
                "cactus_shaped", "candle", "cake", "campfire", "carpet", "cauldron", "chain", "chest", "composter", "conduit", "coral_fan", "coral_plant",
                "daylight_detector", "door", "end_portal_frame", "extended_piston", "farmland_shaped", "fence_gate", "fence", "fire", "grass_shaped", "grindstone",
                "head", "hanging_roots", "hanging_sign", "ladder", "lantern", "lectern", "lever", "mushroom_shaped", "nether_fungus", "nether_sprouts",
                "pane_shaped", "pickle", "piglin_head", "piglin_wall_head", "pink_petals", "piston_head", "pitcher_crop", "pressure_plate", 
                "rail", "redstone_wire", "repeater_shaped", "rod", "sapling", "seagrass", "short_crop", "slab", "small_dripleaf", "sniffer_egg", "snow", 
                "spore_blossom", "sugar_cane_like", "stair", "standing_sign_or_banner", "stem", "stonecutter", "structure_void", 
                "tall_crop", "torchflower_crop", "trapdoor", "tripwire", "tripwire_hook", "turtle_egg", "twisting_vines", 
                "vertical_torch", "vine_like", "wall_banner", "wall_hanging_sign", "wall_head", "wall_sign", "wall_torch", "wall", "weeping_vines"]
            );
            hitbox.cubic(); // if it doesn't match any special hitbox, assume it's a 1x1x1 cube.
        }
    }
    class entity {
        function main() {
            // This doesn't need to be its own function, but now I can add debug stuff later	
            if ($expand_entity_hitboxes != $expand_entity_hitboxes) {
                execute align xyz if entity @e[type=!#retina:intangible, tag=!retina.ignore, tag=!retina.executing, dx=0, dy=0, dz=0] run check.entity.found();
            } else {
                execute align xyz positioned ~-1 ~-1 ~-1 if entity @e[type=!#retina:intangible, tag=!retina.ignore, tag=!retina.executing, dx=2, dy=2, dz=2] positioned ~1 ~1 ~1 run check.entity.found();  //selecting entities from blocks nearby cause of expanded hitboxes
            }

            if (!$hit_entity) return run {
                if ($debug_messages) {
                    Text.tellraw(@a, "&<italic, white>No entity... Coordinates: &<dark_aqua>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
                }
            } 
            
            if ($debug_messages) {
                Text.tellraw(@a, "&<bold, underlined, dark_gray>Entity has been hit! Coordinates: &<dark_aqua>[&<$int_X>, &<$int_Y>, &<$int_Z>]. hit_entity = &<$hit_entity>");
            }
            // if ($end_particle) particle minecraft:soul_fire_flame ~ ~ ~ 0 0 0 0 1 force @a;
        }
        function found() {
            // Clear residual data from `Surfaces`
            data::Surfaces.del();
            data::Surfaces = {Top:[],Bottom:[],West:[],East:[],North:[],South:[]};

            // Identify the entity and get a list of surfaces
            retina.id:$max = 0;
            tag @e[type=!#retina:intangible] remove retina.possible_target;
            if ($expand_entity_hitboxes != $expand_entity_hitboxes) {
                execute align xyz as @e[type=!#retina:intangible, tag=!retina.executing, dx=0, dy=0, dz=0] at @s run check.entity.get_hitbox();
            } else {
                execute align xyz positioned ~-1 ~-1 ~-1 as @e[type=!#retina:intangible, tag=!retina.ignore, tag=!retina.executing, dx=2, dy=2, dz=2] at @s run check.entity.get_hitbox();
            }

            // See if the ray hits any surface
            $contact = false;
            if (data storage retina:data Surfaces) find_closest_surface.main();
            if ($contact) $entity_distance = $min_distance_to_surface;
            $hit_entity = $contact;

            // If the ray could hit both an entity and a block, remember only the one that comes first
            if ($hit_block && $hit_entity && $debug_messages) {
                Text.tellraw(@a, "&<gold>Distance comparison: entity_distance = &<$entity_distance>, block_distance = &<$block_distance>");
            }
            if ($hit_block && $hit_entity && $entity_distance < $block_distance) $hit_block = false;
            if ($hit_block && $hit_entity && $entity_distance >= $block_distance) $hit_entity = false;
        }
        function get_hitbox() {
            execute run {
                Hardcode.repeatList( 
                    "[type]",
                    () => {
                        if (entity @s[type=#retina:[type]] && !$ignore_[type]) {
                            return run entity_hitbox.[type]();
                        }
                    },
                    ["allay", "armadillo", "armor_stand", "axolotl", "bat_like", "bee", "boat", "camel", "cat_like", "cave_spider", "chicken", "cow", "cod", "creeper", 
                    "dolphin", "donkey", "elder_guardian", "end_crystal", "enderman", "falling_block_like", "frog", "ghast", "giant", "guardian",
                    "hoglin", "horse_like",  "iron_golem", "item_frame", "leash_knot", "llama", "minecart", "panda", "phantom", "pig", "player_like", 
                    "polar_bear", "pufferfish", "rabbit", "ravager", "salmon", "sheep_like", "shulker", "skeleton", "slime_like", "small_arthropod", "sniffer",
                    "snow_golem", "spider", "squid", "strider", "tropical_fish", "turtle", "vex", "warden", "wither", "wither_skeleton", "wolf", "zombie_like"]
                );
            }

            // Get the entity's coordinates
            execute summon marker run {
                data::Pos = @s::Pos;
		        
                // Get position (fractional coordinates)
                Hardcode.repeatLists(
                    ["[axis]", "$index"],
                    () => { 
                        $entity_frac_[axis] = data::Pos[$index] * SCALE;
						//$debug_[axis] = $entity_frac_[axis];
                        $temp = SCALE;
                        $temp *= $int_[axis];
                        $entity_frac_[axis] -= $temp;
                    },
                    [["X", "Y", "Z"], ["0", "1", "2"]]
                );

                // Clean up
                data::Pos.del();
                kill @s;
            }

            $entity_half_width = data::entity_half_width * SCALE;
            $entity_height = data::entity_height * SCALE;

            if ($expand_entity_hitboxes == $expand_entity_hitboxes) {
                $entity_half_width += $expand_entity_hitboxes;
                $entity_height += $expand_entity_hitboxes;
            }
        
            Hardcode.repeatList(
                "[i]",
                () => { 
                    $entity_[i]0 = $entity_frac_[i];
                    $entity_[i]0 -= $entity_half_width;
                    $entity_[i]0 > 0;
                    $entity_[i]1 = $entity_frac_[i];
                    $entity_[i]1 += $entity_half_width;
                    $entity_[i]1 < SCALE;
                },
                ["X", "Z"]
            );
            $entity_Y0 = $entity_frac_Y;
            $entity_Y0 > 0;
            $entity_Y1 = $entity_frac_Y;
            $entity_Y1 += $entity_height;
            $entity_Y1 < SCALE;

            // Store these coordinates to storage
            Hardcode.repeatList(
                "[face]", () => {data::Surfaces.[face] << [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];}, 
                ["Top", "Bottom", "West", "East", "North", "South"]
            );

            data::Surfaces.Top[-1][0] = EVAL(1 / SCALE) * (double) $entity_X0;
            data::Surfaces.Top[-1][1] = EVAL(1 / SCALE) * (double) $entity_Y1;
            data::Surfaces.Top[-1][2] = EVAL(1 / SCALE) * (double) $entity_Z0;
            data::Surfaces.Top[-1][3] = EVAL(1 / SCALE) * (double) $entity_X1;
            data::Surfaces.Top[-1][4] = EVAL(1 / SCALE) * (double) $entity_Y1;
            data::Surfaces.Top[-1][5] = EVAL(1 / SCALE) * (double) $entity_Z1;

            data::Surfaces.Bottom[-1][0] = EVAL(1 / SCALE) * (double) $entity_X0;
            data::Surfaces.Bottom[-1][1] = EVAL(1 / SCALE) * (double) $entity_Y0;
            data::Surfaces.Bottom[-1][2] = EVAL(1 / SCALE) * (double) $entity_Z0;
            data::Surfaces.Bottom[-1][3] = EVAL(1 / SCALE) * (double) $entity_X1;
            data::Surfaces.Bottom[-1][4] = EVAL(1 / SCALE) * (double) $entity_Y0;
            data::Surfaces.Bottom[-1][5] = EVAL(1 / SCALE) * (double) $entity_Z1;

            data::Surfaces.West[-1][0] = EVAL(1 / SCALE) * (double) $entity_X0;
            data::Surfaces.West[-1][1] = EVAL(1 / SCALE) * (double) $entity_Y0;
            data::Surfaces.West[-1][2] = EVAL(1 / SCALE) * (double) $entity_Z0;
            data::Surfaces.West[-1][3] = EVAL(1 / SCALE) * (double) $entity_X0;
            data::Surfaces.West[-1][4] = EVAL(1 / SCALE) * (double) $entity_Y1;
            data::Surfaces.West[-1][5] = EVAL(1 / SCALE) * (double) $entity_Z1;

            data::Surfaces.East[-1][0] = EVAL(1 / SCALE) * (double) $entity_X1;
            data::Surfaces.East[-1][1] = EVAL(1 / SCALE) * (double) $entity_Y0;
            data::Surfaces.East[-1][2] = EVAL(1 / SCALE) * (double) $entity_Z0;
            data::Surfaces.East[-1][3] = EVAL(1 / SCALE) * (double) $entity_X1;
            data::Surfaces.East[-1][4] = EVAL(1 / SCALE) * (double) $entity_Y1;
            data::Surfaces.East[-1][5] = EVAL(1 / SCALE) * (double) $entity_Z1;

            data::Surfaces.North[-1][0] = EVAL(1 / SCALE) * (double) $entity_X0;
            data::Surfaces.North[-1][1] = EVAL(1 / SCALE) * (double) $entity_Y0;
            data::Surfaces.North[-1][2] = EVAL(1 / SCALE) * (double) $entity_Z0;
            data::Surfaces.North[-1][3] = EVAL(1 / SCALE) * (double) $entity_X1;
            data::Surfaces.North[-1][4] = EVAL(1 / SCALE) * (double) $entity_Y1;
            data::Surfaces.North[-1][5] = EVAL(1 / SCALE) * (double) $entity_Z0;

            data::Surfaces.South[-1][0] = EVAL(1 / SCALE) * (double) $entity_X0;
            data::Surfaces.South[-1][1] = EVAL(1 / SCALE) * (double) $entity_Y0;
            data::Surfaces.South[-1][2] = EVAL(1 / SCALE) * (double) $entity_Z1;
            data::Surfaces.South[-1][3] = EVAL(1 / SCALE) * (double) $entity_X1;
            data::Surfaces.South[-1][4] = EVAL(1 / SCALE) * (double) $entity_Y1;
            data::Surfaces.South[-1][5] = EVAL(1 / SCALE) * (double) $entity_Z1;

            if (entity @s[type=#retina:item_frame]) entity_hitbox.item_frame(); // Special case for item frames and paintings which are annoying

            // Give this entity a tag and an ID
            tag @s add retina.possible_target;
            retina.id:@s = retina.id:$max;
            retina.id:$max++;
        }
    }
}

class find_closest_surface {
    function main() {
        // @within check.block.found()

        $min_distance_to_surface = EVAL((3 ** 0.5 * SCALE) \ 1);
        Hardcode.repeatLists(
            ["[direction]", "[axis]", "[sign]"],
            () => {if (!$sign_[axis] = [sign] && no_break) find_closest_surface.[direction]();},
            [
                ["east", "west", "top", "bottom", "south", "north"],
                ["X", "X", "Y", "Y", "Z", "Z"],
                ["1", "-1", "1", "-1", "1", "-1"]
            ]
        );
    }
    function store_coords() {
        Hardcode.repeatLists(
            ["[axis]", "index"],
            () => {
                $[axis]0 = data::List[-1][index] * SCALE;
                $[axis]1 = data::List[-1][ Hardcode.calc(index + 3) ] * SCALE;
                $t_[axis] = SCALE;
                $t_[axis] *= $step_[axis];
                $t_[axis] -= $frac_origin_[axis];
                $[axis]0 += $t_[axis];
                $[axis]1 += $t_[axis];
            },
            [
                ["X", "Y", "Z"],
                ["0", "1", "2"]
            ]
        );
        $test = $Y1;
        $test -= $Y0;
        if ($test >= SCALE) return run {
            $head_Y = MAX_INT;
            // no head on lower block
        }
        $head_Y += $t_Y;
        $head_Y -= SCALE;
    }
    function west() {
        // @within find_closest_surface.main()

        data::List = data::Surfaces.West;
        $cuboid_id = $surfaces = data::List;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[0] and List[3] should have the same values)

            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[WEST] &<white>X0: &<light_purple,$X0>");
            execute run {
                if ($output_vec3.X == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $X0;
                $distance /= $output_vec3.X;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;
                
                $X_intersection = $X0; // Get x position of the intersection
            
                // Get y position of the intersection
                $Y_intersection = $X0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.X;
            
                // Get z position of the intersection
                $Z_intersection = $X0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.X;
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[WEST] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[WEST] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($Y_intersection >= $Y0 && $Y_intersection <= $Y1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    output::HitFace = "West";
                    if ($check_for_head && $Y_intersection >= $head_Y) output::HitEntityHead = true;
                }
            }

            // Loop this function
            data::List[-1].del();
            $surfaces --;
            $cuboid_id --;
        }
    }
    function east() {
        // @within find_closest_surface.main()

        data::List = data::Surfaces.East;
        $cuboid_id = $surfaces = data::List;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[0] and List[3] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[EAST] &<white>X0: &<light_purple,$X0>");
            execute run {
                if ($output_vec3.X == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $X0;
                $distance /= $output_vec3.X;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                $X_intersection = $X0; // Get x position of the intersection
            
                // Get y position of the intersection
                $Y_intersection = $X0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.X;
            
                // Get z position of the intersection
                $Z_intersection = $X0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.X;
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[EAST] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[EAST] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($Y_intersection >= $Y0 && $Y_intersection <= $Y1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    output::HitFace = "East";
                    if ($check_for_head && $Y_intersection >= $head_Y) output::HitEntityHead = true;
                }
            }

            // Loop this function
            data::List[-1].del();
            $surfaces --;
            $cuboid_id --;
        }
    }
    function bottom() {
        // @within find_closest_surface.main()

        data::List = data::Surfaces.Bottom;
        $cuboid_id = $surfaces = data::List;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[1] and List[4] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[BOTTOM] &<white>Y0: &<light_purple,$Y0>");
            execute run {
                if ($output_vec3.Y == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Y0;
                $distance /= $output_vec3.Y;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Y0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Y;
                    
                $Y_intersection = $Y0; // Get y position of the intersection
            
                // Get y position of the intersection
                $Z_intersection = $Y0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.Y;

                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[BOTTOM] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[BOTTOM] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>");     
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    output::HitFace = "Bottom";
                    if ($check_for_head && $Y_intersection >= $head_Y) output::HitEntityHead = true;
                }
            }

            // Loop this function
            data::List[-1].del();
            $surfaces --;
            $cuboid_id --;
        }
    }
    function top() {
        // @within find_closest_surface.main()

        data::List = data::Surfaces.Top;
        $cuboid_id = $surfaces = data::List;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[1] and List[4] should have the same values)

            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[TOP] &<white>Y0: &<light_purple,$Y0>");
            execute run {
                if ($output_vec3.Y == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Y0;
                $distance /= $output_vec3.Y;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Y0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Y;
                    
                $Y_intersection = $Y0; // Get y position of the intersection
            
                // Get y position of the intersection
                $Z_intersection = $Y0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.Y;  
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[TOP] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[TOP] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>");     
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    output::HitFace = "Top";
                    if ($check_for_head && $Y_intersection >= $head_Y) output::HitEntityHead = true;
                }
            }

            // Loop this function
            data::List[-1].del();
            $surfaces --;
            $cuboid_id --;
        }
    }
    function north() {
        // @within find_closest_surface.main()

        data::List = data::Surfaces.North;
        $cuboid_id = $surfaces = data::List;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[2] and List[5] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[NORTH] &<white>Z0: &<light_purple,$Z0>");
            execute run {
                if ($output_vec3.Z == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Z0;
                $distance /= $output_vec3.Z;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Z0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Z;
                    
                // Get y position of the intersection
                $Y_intersection = $Z0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.Z;
                
                $Z_intersection = $Z0; // Get z position of the intersection
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[NORTH] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[NORTH] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Y_intersection >= $Y0 && $Y_intersection <= $Y1) {
                    find_closest_surface.ray_intersects_with_surface();
                    output::HitFace = "North";
                    if ($check_for_head && $Y_intersection >= $head_Y) output::HitEntityHead = true;
                }
            }

            // Loop this function
            data::List[-1].del();
            $surfaces --;
            $cuboid_id --;
        }
    }
    function south() {
        // @within find_closest_surface.main()

        data::List = data::Surfaces.South;
        $cuboid_id = $surfaces = data::List;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[2] and List[5] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[SOUTH] &<white>Z0: &<light_purple,$Z0>");
            execute run {
                if ($output_vec3.Z == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Z0;
                $distance /= $output_vec3.Z;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");
            
                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Z0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Z;
                    
                // Get y position of the intersection
                $Y_intersection = $Z0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.Z;
                
                $Z_intersection = $Z0; // Get z position of the intersection
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[SOUTH] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[SOUTH] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Y_intersection >= $Y0 && $Y_intersection <= $Y1) {
                    find_closest_surface.ray_intersects_with_surface();
                    output::HitFace = "South";
                    if ($check_for_head && $Y_intersection >= $head_Y) output::HitEntityHead = true;
                }
            }

            // Loop this function
            data::List[-1].del();
            $surfaces --;
            $cuboid_id --;
        }
    }

    function ray_intersects_with_surface() {
        // Establishes the current surface as the first the ray will hit.
        // This function only runs if the ray is closer to this surface than it is to any other surface analysed so far, but there is no guarantee that this is the surface the ray will eventually hit first.
        
        // @within find_closest_surface.bottom()
        // @within find_closest_surface.east()
        // @within find_closest_surface.north()
        // @within find_closest_surface.south()
        // @within find_closest_surface.top()
        // @within find_closest_surface.west()

        $contact = true;
        $closest_cuboid_id = $cuboid_id;
        $min_distance_to_surface = $distance;

        $targeted_X = $X_intersection;
        $targeted_Y = $Y_intersection;
        $targeted_Z = $Z_intersection;
        data::ContactSurface = data::List[-1];
    }
}

import "hitbox";
import "entity_hitbox";

class storage {
    //	var $total_distance
    //		The distance travelled by the ray before it hits a block. 480 corresponds to one block. Unset if the maximum recursion depth is reached (i.e. if the ray travels at least 20 blocks).
    //	storage retina:output
    //		Target: string
    //			"BLOCK" if the ray hits a block, "ENTITY" if the ray hits an entity, "NONE" if the ray hits nothing.
    //		Distance: double
    //			How long the ray travels before hitting an obstacle.
    //      HitFace: string
    //			Cardinal direction for which face of the block/entity was hit.
    //		TargetedBlock: int[]
    //			The integer coordinates of the block that the ray finds itself in when it hits something (i.e. the "targeted block"). Unset if the ray hits an entity or if no block is found.
    //		TargetedEntity.Pos: float[]
    //			The position of the targeted entity. Unset if the ray hits a block or if no entity is found.
    //		TargetedEntity.UUID: int[]
    //			The UUID of the targeted entity. Unset if the ray hits a block or if no entity is found.
    //		ContactSurface: double[]
    //			The surface of the block or entity the ray hits (six coordinates between 0 and 480, where 0 0 0 and 480 480 480 are opposite corners of the block). Unset if no block or entity is found.
    //		ContactCoordinates: double[]
    //			The exact position where the ray hits something within the targeted block (three coordinates between 0 and 480, where 0 0 0 and 480 480 480 are opposite corners of the block). Unset if no block or entity is found.
    //		PlacingPosition: int[]
    //			The integer coordinates of the block before the ray hits something (i.e. where a block would be placed, if a player were to place a block). Unset if the ray hits an entity or if no block is found.

    function block() {
        output::Target = "BLOCK"; 

        // Reset previous values
        output::TargetedBlock = [0, 0, 0];
        output::PlacingPosition = [0, 0, 0];
        output::ContactCoordinates = [0.0d, 0.0d, 0.0d];

        // Contact surface
        output::ContactSurface = data::ContactSurface;

        // I have no clue why X and Y need this but Z doesn't.
        if ($X0 < 0) $X0 += SCALE;
        if ($Y0 < 0) $Y0 += SCALE;

        Hardcode.repeatLists(
            ["[axis]", "index"],
            () => {
                // Targeted block
                output::TargetedBlock[index] = $int_[axis].get();

                // Placing position
                output::PlacingPosition[index] = $prev_[axis].get();

                // Contact coordinates
                $targeted_[axis] += $origin_[axis];
                output::ContactCoordinates[index] = EVAL(1 / SCALE) * (double) $targeted_[axis];

                // Total distance
                if ($nearest_axis == index) {
                    $total_distance = $delta_[axis];
                    $total_distance *= $[axis]0;
                }
            },
            [["X", "Y", "Z"], ["0", "1", "2"]]
        );
        $total_distance /= SCALE;
        if ($total_distance < 0) $total_distance *= -1;
        output::Distance = EVAL(1 / SCALE) * (double) $total_distance;

        if (data storage retina:input {EndpointEntity: true}) execute summon minecraft:marker run {
            tag @s add retina.endpoint;
            @s::Pos = output::ContactCoordinates;
            if ($end_particle) execute at @s run particle minecraft:electric_spark ~ ~ ~ 0 0 0 0 1 force @a;
        }
    }
    function entity() {
        // Target type
        output::Target = "ENTITY";

        // Targeted entity
        output::TargetedEntity = {UUID: [I; 0, 0, 0, 0], Pos: [0.0f, 0.0f, 0.0f]};
        execute as @e[type=!#retina:ignore, tag=retina.possible_target] if score @s retina.id = $closest_cuboid_id retina.__variable__ run {
            tag @s add retina.target;
            retina.hit:@s++;
        }
        data::Entity = @e[type=!#retina:ignore, tag=retina.target, limit=1]::;
        output::TargetedEntity.UUID = data::Entity.UUID;
        output::TargetedEntity.Pos = data::Entity.Pos;
        data::Entity.del();

        // Contact surface
        output::ContactSurface = data::ContactSurface;

        // Contact coordinates
        output::ContactCoordinates = [0.0d, 0.0d, 0.0d];

        // I have no clue why X and Y need this but Z doesn't.
        if ($X0 < 0) $X0 += SCALE;
        if ($Y0 < 0) $Y0 += SCALE;
        
        if ($expand_entity_hitboxes == $expand_entity_hitboxes) {
            //adding correction for expanded hitboxes, so that the contact coordinates are on the actual entity hitbox
            if (data storage retina:output {HitFace: "North"}) $targeted_Z += $expand_entity_hitboxes;
            if (data storage retina:output {HitFace: "South"}) $targeted_Z -= $expand_entity_hitboxes;
            if (data storage retina:output {HitFace: "East"}) $targeted_X -= $expand_entity_hitboxes;
            if (data storage retina:output {HitFace: "West"}) $targeted_X += $expand_entity_hitboxes;
            if (data storage retina:output {HitFace: "Top"}) $targeted_Y -= $expand_entity_hitboxes;
            if (data storage retina:output {HitFace: "Bottom"}) $targeted_Y += $expand_entity_hitboxes;
        }

        Hardcode.repeatLists(
            ["[axis]", "_index"],
            () => {
                $targeted_[axis] += $origin_[axis];
                output::ContactCoordinates[_index] = EVAL(1 / SCALE) * (double) $targeted_[axis];

                // Total distance
                if ($nearest_axis == _index) {
                    $total_distance = $delta_[axis];
                    $total_distance *= $[axis]0;
                }
            },
            [["X", "Y", "Z"], ["0", "1", "2"]]
        );
        $total_distance /= SCALE;
        if ($total_distance < 0) $total_distance *= -1;
        output::Distance = EVAL(1 / SCALE) * (double) $total_distance;
        if (data storage retina:input {EndpointEntity: true}) execute summon minecraft:marker run {
            tag @s add retina.endpoint;
            @s::Pos = output::ContactCoordinates;
            if ($end_particle) execute at @s run particle minecraft:electric_spark ~ ~ ~ 0 0 0 0 1 force @a;
        }
    }
}

$old_version_installed ?= scoreboard players add * retina 1;
if ($old_version_installed) {
    scoreboard objectives remove retina;
    scoreboard objectives remove retina.show_particle;
    scoreboard objectives remove retina.show_line;
    scoreboard objectives remove retina.raycast_count;
    scoreboard objectives remove retinacasttemp;
    kill @e[type=marker, tag=retina.ray];
    kill @e[type=marker, tag=retina.get_coordinates];
}
function uninstall() {}
return 1;