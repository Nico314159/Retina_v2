import "math";
import "tags";

//summon minecraft:marker 0 0 0 {Tags:["retina.height","retina.ignore"]};
$overflow_risk = 2147483647;
$overflow_risk /= SCALE;
Scoreboard.add(retina.id, dummy);
Scoreboard.add(retina.hit, dummy);
data merge storage retina:input {HorizontalCount: 1b, VerticalCount: 1b, CenteredCount: 0b, SpreadFactor: [100, 100], EndpointEntity: 0b};
if (!data storage retina:input MaxRecursionDepth) data merge storage retina:input {MaxRecursionDepth: 50};
if (!data storage retina:input TargetEntities) data merge storage retina:input {TargetEntities: true};
data merge storage retina:output {ContactCoordinates: [], ContactSurface: [], Distance: 0.0d, HitFace: "", PlacingPosition: [], Target: "", TargetedBlock: []};

class traverse {
    function setup() {
        data modify storage retina:output Target set value "NONE";
        data modify storage retina:output Distance set from storage retina:input MaxRecursionDepth;
        data modify storage retina:output HitEntityHead set value false;
        data remove storage retina:output TargetedBlock;
        data remove storage retina:output TargetedEntity;
        data remove storage retina:output PlacingPosition;
        data remove storage retina:output ContactSurface;
        data remove storage retina:output HitFace;
        
        // guard condition
        Hardcode.repeatList(
            "[i]",
            () => {
                $int_[i] = data get entity @s Pos[0] 1;
                $test_[i] = $int_[i];
                $test_[i] /= $overflow_risk;
                if (!$test_[i] matches -1..0) Text.tellraw(@a, "&<dark_red>[Error] &<red>Raycast [i] coordinate of &<$int_[i]> is out of range (-&<$overflow_risk>, &<$overflow_risk>)");
                if (!$test_[i] matches -1..0) return 0;
            },
            ["X", "Z"] // not worried about Y since that's never gonna be high enough to overflow
        );
        
        $block_distance = $entity_distance = 2147483647;
		$hit_block = $hit_entity = $contact = false;
        $max_depth = data get storage retina:input MaxRecursionDepth;

        tag @s add retina.executing;
        if ($single_call) {
            tag @e remove retina.target;
            scoreboard players reset * retina.hit;
            kill @e[type=marker,tag=retina.endpoint];
            $input_pitch = data get entity @s Rotation[1] 10;
            $input_yaw = data get entity @s Rotation[0] 10;
            if ($debug_messages) Text.tellraw(@a, "&<!bold, white>Pitch: &<$input_pitch, red>, &<!bold, white>Yaw: &<$input_yaw, red>");
            Math.gimbal_to_vec();
            if ($debug_messages) Text.tellraw(@a, "Facing Vector: &<gold>[&<$output_vec3.X>, &<$output_vec3.Y>, &<$output_vec3.Z>]");
        }

        execute anchored eyes positioned ^ ^ ^ summon minecraft:marker run {
            $X = data get entity @s Pos[0] SCALE;
            $Y = data get entity @s Pos[1] SCALE;
            $Z = data get entity @s Pos[2] SCALE;
            kill @s;
        }
        Hardcode.repeatList(
            "[i]",
            () => {
                $origin_[i] = $[i];
                $frac_origin_[i] = $[i];
                $frac_origin_[i] %= SCALE;
                $step_[i] = 0;

                if ($output_vec3.[i] < 0) $sign_[i] = -1;
                if ($output_vec3.[i] >= 0) $sign_[i] = 1;

                $delta_[i] = 230400;
                $delta_[i] /= $output_vec3.[i];
                $delta_[i] /= $sign_[i];

                $distance_[i] = $[i];
                $distance_[i] *= $sign_[i];
                $distance_[i] *= -1;
                $distance_[i] %= SCALE;
                $distance_[i] *= $delta_[i];
                $distance_[i] /= SCALE;

                if ($output_vec3.[i] == 0) $delta_[i] = $distance_[i] = 2147483647;

                $int_[i] = $[i];
                $int_[i] /= SCALE;
            },
            ["X", "Y", "Z"]
        );
        if ($debug_messages) Text.tellraw(@a, "Origin: &<yellow>[&<$int_X>, &<$int_Y>, &<$int_Z>]");

        $step = 0;
        $offset_Y = data get entity @s Pos[1] -SCALE;
        $offset_Y += $Y;
        if ($offset_Y matches 776..778) execute positioned ~ ~1.62 ~ run traverse.loop();
        if ($offset_Y matches 608..610) execute positioned ~ ~1.27 ~ run traverse.loop();
        if ($offset_Y = 192) execute positioned ~ ~0.4 ~ run traverse.loop();

        if ($hit_block) storage.block();
        if ($hit_entity) storage.entity();
        execute run function #retina:on_hit;
        tag @s remove retina.executing;
    }
    function loop() {
        // Find nearest axis
        $shortest_distance = $distance_X;
        $shortest_distance < $distance_Y;
        $shortest_distance < $distance_Z;
        if ($shortest_distance = $distance_Z) $nearest_axis = 2;
        if ($shortest_distance = $distance_Y) $nearest_axis = 1;
        if ($shortest_distance = $distance_X) $nearest_axis = 0;
        
        $prev_X = $int_X;
        $prev_Y = $int_Y;
        $prev_Z = $int_Z;

        if ($debug_messages == 2) particle crit;

        // Process data based on nearest axis
        if ($nearest_axis = 0 && no_break) traverse.x();
        if ($nearest_axis = 1 && no_break) traverse.y();
        if ($nearest_axis = 2 && no_break) traverse.z();
    }
    function x() {
        if ($debug_messages) Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
        if ($debug_messages) Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>X");
        $distance_X += $delta_X;
        $step_X += $sign_X;
        $int_X += $sign_X;

        if ($sign_X = -1) execute positioned ~-1 ~0 ~0 run check.main();
        if ($sign_X = 1) execute positioned ~1 ~0 ~0 run check.main();
    }
    function y() {
        if ($debug_messages) Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
        if ($debug_messages) Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Y");
        $distance_Y += $delta_Y;
        $step_Y += $sign_Y;
        $int_Y += $sign_Y;

        if ($sign_Y = -1) execute positioned ~0 ~-1 ~0 run check.main();
        if ($sign_Y = 1) execute positioned ~0 ~1 ~0 run check.main();
    }
    function z() {
        if ($debug_messages) Text.tellraw(@a, "Distances to each block: &<green>[&<$distance_X>, &<$distance_Y>, &<$distance_Z>]");
        if ($debug_messages) Text.tellraw(@a, "&<!bold, white>Closest direction: &<bold,aqua>Z");
        $distance_Z += $delta_Z;
        $step_Z += $sign_Z;
        $int_Z += $sign_Z;

        if ($sign_Z = -1) execute positioned ~0 ~0 ~-1 run check.main();
        if ($sign_Z = 1) execute positioned ~0 ~0 ~1 run check.main();
    }
    function multicast() {
        $horizontal_count = data get storage retina:input HorizontalCount 10;
        $vertical_count = data get storage retina:input VerticalCount 10;
        $centered_count = data get storage retina:input CenteredCount 1;

        // input validation
        if ($horizontal_count <= 0) Text.tellraw(@a, "&<dark_red>[Error] &<red>HorizontalCount storage has invalid value of &<$horizontal_count>");
        if ($horizontal_count <= 0) return 0;
        if ($vertical_count <= 0) Text.tellraw(@a, "&<dark_red>[Error] &<red>VerticalCount storage has invalid value of &<$vertical_count>");
        if ($vertical_count <= 0) return 0;
        if ($centered_count < 0) Text.tellraw(@a, "&<dark_red>[Error] &<red>CenteredCount storage has invalid value of &<$centered_count>");
        if ($centered_count < 0) return 0;

        $spread_least = data get storage retina:input SpreadFactor[0];
        $spread_range = data get storage retina:input SpreadFactor[1];
        $spread_range -= $spread_least;

        $single_call = false;
        tag @e remove retina.target;
        scoreboard players reset * retina.hit;
        kill @e[type=marker,tag=retina.endpoint];
        $input_pitch = data get entity @s Rotation[1] 10;
        $input_yaw = data get entity @s Rotation[0] 10;
        for ($i = 0; $i < $horizontal_count; $i += 10) { 
            for ($j = 0; $j < $vertical_count; $j += 10) {
                $input_vec3.X = $i;
                $input_vec3.X *= 2;
                $input_vec3.X += 10;
                $input_vec3.X -= $horizontal_count;
                if ($horizontal_count == 10) {
                    $input_vec3.X = Math.random(2, 6);
                    $input_vec3.X %= 3;
                    $input_vec3.X --;
                    $input_vec3.X *= 20;
                }
                $spread = Math.random();
                $spread %= $spread_range;
                $spread += $spread_least;
                if ($spread_range == 0) $spread = $spread_least;
                $input_vec3.X *= $spread;
                $input_vec3.X /= 100;

                $input_vec3.Y = $j;
                $input_vec3.Y *= 2;
                $input_vec3.Y += 10;
                $input_vec3.Y -= $vertical_count;
                if ($vertical_count == 10) {
                    $input_vec3.Y = Math.random(2, 6);
                    $input_vec3.Y %= 3;
                    $input_vec3.Y --;
                    $input_vec3.Y *= 20;
                }
                $spread = Math.random();
                $spread %= $spread_range;
                $spread += $spread_least;
                if ($spread_range == 0) $spread = $spread_least;
                $input_vec3.Y *= $spread;
                $input_vec3.Y /= 100;

                $input_vec3.Z = 500;
                if ($debug_messages) Text.tellraw(@a, "Input Vector: &<red, italic>[&<$input_vec3.X, italic>, &<$input_vec3.Y, italic>, &<$input_vec3.Z, italic>]"); 

                $length = 0;
                Hardcode.repeatList("[axis]", () => {$temp = $input_vec3.[axis]; $temp *= $input_vec3.[axis]; $length += $temp;}, ["X", "Y", "Z"]);
                $length = Math.sqrt($length);
                Math.gimbal_to_matrix();
                Hardcode.repeatList("[pair]", () => {$input_mat3.[pair] = $output_mat3.[pair];}, ["XX", "XY", "XZ", "YX", "YY", "YZ", "ZX", "ZY", "ZZ"]);
                Math.matrix_transform();
                Hardcode.repeatList("[axis]", () => {$output_vec3.[axis] *= SCALE; $output_vec3.[axis] /= $length;}, ["X", "Y", "Z"]);
                if ($debug_messages) Text.tellraw(@a, "Angled Vector: &<gold, italic>[&<$output_vec3.X, italic>, &<$output_vec3.Y, italic>, &<$output_vec3.Z, italic>]");
                traverse.setup();
            } 
        }

        for ($k = 0; $k < $centered_count; $k++) {traverse.setup();}
        $single_call = true;
    }
}   

class check {
    function main() {
        $step ++;

        $check_for_head = false;
        check.block.main();
        if (data storage retina:input {TargetEntities: true}) check.entity.main();

        if ($step >= $max_depth && $debug_messages) Text.tellraw(@a, "&<italic, light_purple>Failed to find anything within &<$step> blocks. End coordinates: &<bold>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
        if (no_break) traverse.loop();
    }
    class block {
        function main() {
            if (block ~ ~ ~ #retina:airs) return 0;
            check.block.found();
            if (!$hit_block && $debug_messages) Text.tellraw(@a, "&<italic, white>No block... Coordinates: &<blue>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
            if (!$hit_block) return 0;
            
            if ($debug_messages) Text.tellraw(@a, "&<bold, underlined, gray>Block has been hit! Coordinates: &<blue>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
            if ($debug_gold) setblock ~ ~ ~ gold_block;
            // if ($end_particle) particle minecraft:end_rod ~ ~ ~ 0 0 0 0 1 force @a;
        }
        function found() {
            // Clear residual data from `Surfaces`
            data remove storage retina:data Surfaces;
            data modify storage retina:data Surfaces set value {Top:[],Bottom:[],West:[],East:[],North:[],South:[]};
            check.block.get_hitbox();

            // See if the ray hits any surface
            if (data storage retina:data Surfaces) find_closest_surface.main(); 
            if ($contact) $block_distance = $min_distance_to_surface;
            $hit_block = $contact;
        }
        function get_hitbox() {
            Hardcode.repeatList(
                "[shape]",
                () => { 
                    if (block ~ ~ ~ #retina:[shape] && !$ignore_[shape]) hitbox.[shape]();
                    if (block ~ ~ ~ #retina:[shape] && !$ignore_[shape]) return 1;
                },
                ["amethyst", "anvil", "attached_stem", "azalea", "bed", "bell", "berries", "big_dripleaf", "big_dripleaf_stem", "brewing_stand", "button", 
                "cactus_shaped", "candle", "cake", "campfire", "carpet", "cauldron", "chain", "chest", "composter", "conduit", "coral_fan", "coral_plant",
                "daylight_detector", "door", "end_portal_frame", "extended_piston", "farmland_shaped", "fence_gate", "fence", "fire", "grass_shaped", "grindstone",
                "head", "hanging_roots", "hanging_sign", "ladder", "lantern", "lectern", "lever", "mushroom_shaped", "nether_fungus", "nether_sprouts",
                "pane_shaped", "pickle", "piglin_head", "piglin_wall_head", "pink_petals", "piston_head", "pitcher_crop", "pressure_plate", "rail", "repeater_shaped", "rod",
                "sapling", "seagrass", "short_crop", "slab", "small_dripleaf", "sniffer_egg", "snow", "spore_blossom", "sugar_cane_like", "stair", "standing_sign_or_banner", 
                "stem", "stonecutter", "structure_void", "tall_crop", "torchflower_crop", "trapdoor", "tripwire", "tripwire_hook", "turtle_egg", "twisting_vines", 
                "vertical_torch", "vine_like", "wall_banner", "wall_hanging_sign", "wall_head", "wall_sign", "wall_torch", "wall", "weeping_vines"]
            );
            hitbox.cubic(); // if it doesn't match any special hitbox, assume it's a 1x1x1 cube.
        }
    }
    class entity {
        function main() {
            // This doesn't need to be its own function, but now I can add debug stuff later	
            execute align xyz if entity @e[type=!#retina:intangible, tag=!retina.ignore, tag=!retina.executing, dx=0, dy=0, dz=0] run check.entity.found();
            if (!$hit_entity && $debug_messages) Text.tellraw(@a, "&<italic, white>No entity... Coordinates: &<dark_aqua>[&<$int_X>, &<$int_Y>, &<$int_Z>]");
            if (!$hit_entity) return 0;
            
            if ($debug_messages) Text.tellraw(@a, "&<bold, underlined, dark_gray>Entity has been hit! Coordinates: &<dark_aqua>[&<$int_X>, &<$int_Y>, &<$int_Z>]. hit_entity = &<$hit_entity>");
            // if ($end_particle) particle minecraft:soul_fire_flame ~ ~ ~ 0 0 0 0 1 force @a;
        }
        function found() {
            // Clear residual data from `Surfaces`
            data remove storage retina:data Surfaces;
            data modify storage retina:data Surfaces set value {Top:[],Bottom:[],West:[],East:[],North:[],South:[]};

            // Identify the entity and get a list of surfaces
            retina.id:$max = 0;
            tag @e[type=!#retina:intangible] remove retina.possible_target;
            execute align xyz as @e[type=!#retina:intangible, tag=!retina.executing, dx=0, dy=0, dz=0] at @s run check.entity.get_hitbox();

            // See if the ray hits any surface
            $contact = false;
            if (data storage retina:data Surfaces) find_closest_surface.main();
            if ($contact) $entity_distance = $min_distance_to_surface;
            $hit_entity = $contact;

            // If the ray could hit both an entity and a block, remember only the one that comes first
            if ($hit_block && $hit_entity && $debug_messages) Text.tellraw(@a, "&<gold>Distance comparison: entity_distance = &<$entity_distance>, block_distance = &<$block_distance>");
            if ($hit_block && $hit_entity && $entity_distance < $block_distance) $hit_block = false;
            if ($hit_block && $hit_entity && $entity_distance >= $block_distance) $hit_entity = false;
        }
        function get_hitbox() {
            execute run {
                Hardcode.repeatList( 
                    "[type]",
                    () => {
                        if (entity @s[type=#retina:[type]] && !$ignore_[type]) entity_hitbox.[type]();
                        if (entity @s[type=#retina:[type]] && !$ignore_[type]) return 1;
                    },
                    ["allay", "armor_stand", "axolotl", "bat_like", "bee", "boat", "camel", "cat_like", "cave_spider", "chicken", "cow", "cod", "creeper", 
                    "dolphin", "donkey", "elder_guardian", "end_crystal", "enderman", "falling_block_like", "frog", "ghast", "giant", "guardian",
                    "hoglin", "horse_like",  "iron_golem", "item_frame", "leash_knot", "llama", "minecart", "panda", "phantom", "pig", "player_like", 
                    "polar_bear", "pufferfish", "rabbit", "ravager", "salmon", "sheep_like", "shulker", "skeleton", "slime_like", "small_arthropod", "sniffer",
                    "snow_golem", "spider", "squid", "strider", "tropical_fish", "turtle", "vex", "warden", "wither", "wither_skeleton", "wolf", "zombie_like"]
                );
            }

            // Get the entity's coordinates
            execute summon marker run {
                data modify storage retina:data Pos set from entity @s Pos;
		        
                // Get position (fractional coordinates)
                Hardcode.repeatLists(
                    ["[axis]", "$index"],
                    () => { 
                        $entity_frac_[axis] = data get storage retina:data Pos[$index] SCALE;
						//$debug_[axis] = $entity_frac_[axis];
                        $temp = SCALE;
                        $temp *= $int_[axis];
                        $entity_frac_[axis] -= $temp;
                    },
                    [["X", "Y", "Z"], ["0", "1", "2"]]
                );

                // Clean up
                data remove storage retina:data Pos;
                kill @s;
            }
        
            Hardcode.repeatList(
                "[i]",
                () => { 
                    $entity_[i]0 = $entity_frac_[i];
                    $entity_[i]0 -= $entity_half_width;
                    $entity_[i]0 > 0;
                    $entity_[i]1 = $entity_frac_[i];
                    $entity_[i]1 += $entity_half_width;
                    $entity_[i]1 < SCALE;
                },
                ["X", "Z"]
            );
            $entity_Y0 = $entity_frac_Y;
            $entity_Y0 > 0;
            $entity_Y1 = $entity_frac_Y;
            $entity_Y1 += $entity_height;
            $entity_Y1 < SCALE;

            // Store these coordinates to storage
            Hardcode.repeatList(
                "[face]", () => {data modify storage retina:data Surfaces.[face] append value [0, 0, 0, 0, 0, 0];}, 
                ["Top", "Bottom", "West", "East", "North", "South"]
            );

            execute store result storage retina:data Surfaces.Top[-1][0] int 1 run $entity_X0.get();
            execute store result storage retina:data Surfaces.Top[-1][1] int 1 run $entity_Y1.get();
            execute store result storage retina:data Surfaces.Top[-1][2] int 1 run $entity_Z0.get();
            execute store result storage retina:data Surfaces.Top[-1][3] int 1 run $entity_X1.get();
            execute store result storage retina:data Surfaces.Top[-1][4] int 1 run $entity_Y1.get();
            execute store result storage retina:data Surfaces.Top[-1][5] int 1 run $entity_Z1.get();

            execute store result storage retina:data Surfaces.Bottom[-1][0] int 1 run $entity_X0.get();
            execute store result storage retina:data Surfaces.Bottom[-1][1] int 1 run $entity_Y0.get();
            execute store result storage retina:data Surfaces.Bottom[-1][2] int 1 run $entity_Z0.get();
            execute store result storage retina:data Surfaces.Bottom[-1][3] int 1 run $entity_X1.get();
            execute store result storage retina:data Surfaces.Bottom[-1][4] int 1 run $entity_Y0.get();
            execute store result storage retina:data Surfaces.Bottom[-1][5] int 1 run $entity_Z1.get();

            execute store result storage retina:data Surfaces.West[-1][0] int 1 run $entity_X0.get();
            execute store result storage retina:data Surfaces.West[-1][1] int 1 run $entity_Y0.get();
            execute store result storage retina:data Surfaces.West[-1][2] int 1 run $entity_Z0.get();
            execute store result storage retina:data Surfaces.West[-1][3] int 1 run $entity_X0.get();
            execute store result storage retina:data Surfaces.West[-1][4] int 1 run $entity_Y1.get();
            execute store result storage retina:data Surfaces.West[-1][5] int 1 run $entity_Z1.get();

            execute store result storage retina:data Surfaces.East[-1][0] int 1 run $entity_X1.get();
            execute store result storage retina:data Surfaces.East[-1][1] int 1 run $entity_Y0.get();
            execute store result storage retina:data Surfaces.East[-1][2] int 1 run $entity_Z0.get();
            execute store result storage retina:data Surfaces.East[-1][3] int 1 run $entity_X1.get();
            execute store result storage retina:data Surfaces.East[-1][4] int 1 run $entity_Y1.get();
            execute store result storage retina:data Surfaces.East[-1][5] int 1 run $entity_Z1.get();

            execute store result storage retina:data Surfaces.North[-1][0] int 1 run $entity_X0.get();
            execute store result storage retina:data Surfaces.North[-1][1] int 1 run $entity_Y0.get();
            execute store result storage retina:data Surfaces.North[-1][2] int 1 run $entity_Z0.get();
            execute store result storage retina:data Surfaces.North[-1][3] int 1 run $entity_X1.get();
            execute store result storage retina:data Surfaces.North[-1][4] int 1 run $entity_Y1.get();
            execute store result storage retina:data Surfaces.North[-1][5] int 1 run $entity_Z0.get();

            execute store result storage retina:data Surfaces.South[-1][0] int 1 run $entity_X0.get();
            execute store result storage retina:data Surfaces.South[-1][1] int 1 run $entity_Y0.get();
            execute store result storage retina:data Surfaces.South[-1][2] int 1 run $entity_Z1.get();
            execute store result storage retina:data Surfaces.South[-1][3] int 1 run $entity_X1.get();
            execute store result storage retina:data Surfaces.South[-1][4] int 1 run $entity_Y1.get();
            execute store result storage retina:data Surfaces.South[-1][5] int 1 run $entity_Z1.get();

            if (entity @s[type=#retina:item_frame]) entity_hitbox.item_frame(); // Special case for item frames and paintings which are annoying

            // Give this entity a tag and an ID
            tag @s add retina.possible_target;
            retina.id:@s = retina.id:$max;
            retina.id:$max++;
        }
    }
}

class find_closest_surface {
    function main() {
        // @within check.block.found()

        $min_distance_to_surface = 832; // sqrt(3) * 480
        Hardcode.repeatLists(
            ["[direction]", "[axis]", "[sign]"],
            () => {if (!$sign_[axis] = [sign] && no_break) find_closest_surface.[direction]();},
            [
                ["east", "west", "top", "bottom", "south", "north"],
                ["X", "X", "Y", "Y", "Z", "Z"],
                ["1", "-1", "1", "-1", "1", "-1"]
            ]
        );
    }
    function store_coords() {
        Hardcode.repeatLists(
            ["[axis]", "index"],
            () => {
                $[axis]0 = data get storage retina:data List[-1][index];
                $[axis]1 = data get storage retina:data List[-1][ Hardcode.calc(index + 3) ];
                $t_[axis] = 480;
                $t_[axis] *= $step_[axis];
                $t_[axis] -= $frac_origin_[axis];
                $[axis]0 += $t_[axis];
                $[axis]1 += $t_[axis];
            },
            [
                ["X", "Y", "Z"],
                ["0", "1", "2"]
            ]
        );
        $test = $Y1;
        $test -= $Y0;
        if ($test < 480) expand {
            $head_Y += $t_Y;
            $head_Y -= 480;
        }
    }
    function west() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.West;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[0] and List[3] should have the same values)

            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[WEST] &<white>X0: &<light_purple,$X0>");
            execute run {
                if ($output_vec3.X == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $X0;
                $distance /= $output_vec3.X;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;
                
                $X_intersection = $X0; // Get x position of the intersection
            
                // Get y position of the intersection
                $Y_intersection = $X0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.X;
            
                // Get z position of the intersection
                $Z_intersection = $X0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.X;
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[WEST] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[WEST] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($Y_intersection >= $Y0 && $Y_intersection <= $Y1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    data modify storage retina:output HitFace set value "West";
                    if ($check_for_head && $Y_intersection >= $head_Y) data modify storage retina:output HitEntityHead set value true;
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function east() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.East;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[0] and List[3] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[EAST] &<white>X0: &<light_purple,$X0>");
            execute run {
                if ($output_vec3.X == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $X0;
                $distance /= $output_vec3.X;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                $X_intersection = $X0; // Get x position of the intersection
            
                // Get y position of the intersection
                $Y_intersection = $X0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.X;
            
                // Get z position of the intersection
                $Z_intersection = $X0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.X;
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[EAST] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[EAST] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($Y_intersection >= $Y0 && $Y_intersection <= $Y1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    data modify storage retina:output HitFace set value "East";
                    if ($check_for_head && $Y_intersection >= $head_Y) data modify storage retina:output HitEntityHead set value true;
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function bottom() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.Bottom;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[1] and List[4] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[BOTTOM] &<white>Y0: &<light_purple,$Y0>");
            execute run {
                if ($output_vec3.Y == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Y0;
                $distance /= $output_vec3.Y;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Y0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Y;
                    
                $Y_intersection = $Y0; // Get y position of the intersection
            
                // Get y position of the intersection
                $Z_intersection = $Y0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.Y;

                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[BOTTOM] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[BOTTOM] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>");     
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    data modify storage retina:output HitFace set value "Bottom";
                    if ($check_for_head && $Y_intersection >= $head_Y) data modify storage retina:output HitEntityHead set value true;
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function top() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.Top;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[1] and List[4] should have the same values)

            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[TOP] &<white>Y0: &<light_purple,$Y0>");
            execute run {
                if ($output_vec3.Y == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Y0;
                $distance /= $output_vec3.Y;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Y0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Y;
                    
                $Y_intersection = $Y0; // Get y position of the intersection
            
                // Get y position of the intersection
                $Z_intersection = $Y0;
                $Z_intersection *= $output_vec3.Z;
                $Z_intersection /= $output_vec3.Y;  
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[TOP] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[TOP] &<!bold>Z-Int: &<!italic,light_purple,$Z_intersection>, &<italic,white>Z0: &<!italic,light_purple,$Z0>, &<italic,white>Z1: &<!italic,light_purple,$Z1>");     
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Z_intersection >= $Z0 && $Z_intersection <= $Z1) {
                    find_closest_surface.ray_intersects_with_surface();
                    data modify storage retina:output HitFace set value "Top";
                    if ($check_for_head && $Y_intersection >= $head_Y) data modify storage retina:output HitEntityHead set value true;
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function north() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.North;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[2] and List[5] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[NORTH] &<white>Z0: &<light_purple,$Z0>");
            execute run {
                if ($output_vec3.Z == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Z0;
                $distance /= $output_vec3.Z;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");

                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Z0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Z;
                    
                // Get y position of the intersection
                $Y_intersection = $Z0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.Z;
                
                $Z_intersection = $Z0; // Get z position of the intersection
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[NORTH] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[NORTH] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Y_intersection >= $Y0 && $Y_intersection <= $Y1) {
                    find_closest_surface.ray_intersects_with_surface();
                    data modify storage retina:output HitFace set value "North";
                    if ($check_for_head && $Y_intersection >= $head_Y) data modify storage retina:output HitEntityHead set value true;
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }
    function south() {
        // @within find_closest_surface.main()

        data modify storage retina:data List set from storage retina:data Surfaces.South;
        $surfaces = data get storage retina:data List;
        $cuboid_id = $surfaces;
        $cuboid_id --;
        while ($surfaces >= 1) {
            find_closest_surface.store_coords(); // Store all coordinates to scores (List[2] and List[5] should have the same values)
            
            if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[SOUTH] &<white>Z0: &<light_purple,$Z0>");
            execute run {
                if ($output_vec3.Z == 0) return 0; // The code block is actually its own function, so this gives control back to the while loop.
                $distance = $Z0;
                $distance /= $output_vec3.Z;
                if ($debug_messages) Text.tellraw(@a, "&<italic>Distance: &<light_purple,$distance>");
            
                // If this distance is closer than the minimum distance to a surface hit by the ray found so far, see if the ray intersects with the surface
                if (!$distance < $min_distance_to_surface) return 0;

                // Get x position of the intersection
                $X_intersection = $Z0;
                $X_intersection *= $output_vec3.X;
                $X_intersection /= $output_vec3.Z;
                    
                // Get y position of the intersection
                $Y_intersection = $Z0;
                $Y_intersection *= $output_vec3.Y;
                $Y_intersection /= $output_vec3.Z;
                
                $Z_intersection = $Z0; // Get z position of the intersection
            
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[SOUTH] &<!bold>X-Int: &<!italic,light_purple,$X_intersection>, &<italic,white>X0: &<!italic,light_purple,$X0>, &<italic,white>X1: &<!italic,light_purple,$X1>");
                if ($debug_messages) Text.tellraw(@a, "&<italic,bold>[SOUTH] &<!bold>Y-Int: &<!italic,light_purple,$Y_intersection>, &<italic,white>Y0: &<!italic,light_purple,$Y0>, &<italic,white>Y1: &<!italic,light_purple,$Y1>"); 
                // If the ray hits the surface, return this as the minimum distance and the contact surface
                if ($X_intersection >= $X0 && $X_intersection <= $X1 && $Y_intersection >= $Y0 && $Y_intersection <= $Y1) {
                    find_closest_surface.ray_intersects_with_surface();
                    data modify storage retina:output HitFace set value "South";
                    if ($check_for_head && $Y_intersection >= $head_Y) data modify storage retina:output HitEntityHead set value true;
                }
            }

            // Loop this function
            data remove storage retina:data List[-1];
            $surfaces --;
            $cuboid_id --;
        }
    }

    function ray_intersects_with_surface() {
        // Establishes the current surface as the first the ray will hit.
        // This function only runs if the ray is closer to this surface than it is to any other surface analysed so far, but there is no guarantee that this is the surface the ray will eventually hit first.
        
        // @within find_closest_surface.bottom()
        // @within find_closest_surface.east()
        // @within find_closest_surface.north()
        // @within find_closest_surface.south()
        // @within find_closest_surface.top()
        // @within find_closest_surface.west()

        $contact = true;
        $closest_cuboid_id = $cuboid_id;
        $min_distance_to_surface = $distance;

        $targeted_X = $X_intersection;
        $targeted_Y = $Y_intersection;
        $targeted_Z = $Z_intersection;
        data modify storage retina:data ContactSurface set from storage retina:data List[-1];
    }
}

import "hitbox";
import "entity_hitbox";

class storage {
    //	var $total_distance
    //		The distance travelled by the ray before it hits a block. 480 corresponds to one block. Unset if the maximum recursion depth is reached (i.e. if the ray travels at least 20 blocks).
    //	storage retina:output
    //		Target: string
    //			"BLOCK" if the ray hits a block, "ENTITY" if the ray hits an entity, "NONE" if the ray hits nothing.
    //		Distance: double
    //			How long the ray travels before hitting an obstacle.
    //      HitFace: string
    //			Cardinal direction for which face of the block/entity was hit.
    //		TargetedBlock: int[]
    //			The integer coordinates of the block that the ray finds itself in when it hits something (i.e. the "targeted block"). Unset if the ray hits an entity or if no block is found.
    //		TargetedEntity.Pos: float[]
    //			The position of the targeted entity. Unset if the ray hits a block or if no entity is found.
    //		TargetedEntity.UUID: int[]
    //			The UUID of the targeted entity. Unset if the ray hits a block or if no entity is found.
    //		ContactSurface: double[]
    //			The surface of the block or entity the ray hits (six coordinates between 0 and 480, where 0 0 0 and 480 480 480 are opposite corners of the block). Unset if no block or entity is found.
    //		ContactCoordinates: double[]
    //			The exact position where the ray hits something within the targeted block (three coordinates between 0 and 480, where 0 0 0 and 480 480 480 are opposite corners of the block). Unset if no block or entity is found.
    //		PlacingPosition: int[]
    //			The integer coordinates of the block before the ray hits something (i.e. where a block would be placed, if a player were to place a block). Unset if the ray hits an entity or if no block is found.

    function block() {
        data modify storage retina:output Target set value "BLOCK"; 

        // Reset previous values
        data modify storage retina:output TargetedBlock set value [0, 0, 0];
        data modify storage retina:output PlacingPosition set value [0, 0, 0];
        data modify storage retina:output ContactCoordinates set value [0.0d, 0.0d, 0.0d];

        // Contact surface
        data modify storage retina:output ContactSurface set from storage retina:data ContactSurface;

        // I have no clue why X and Y need this but Z doesn't.
        if ($X0 < 0) $X0 += 480;
        if ($Y0 < 0) $Y0 += 480;

        Hardcode.repeatLists(
            ["[axis]", "index"],
            () => {
                // Targeted block
                execute store result storage retina:output TargetedBlock[index] int 1 run $int_[axis].get();

                // Placing position
                execute store result storage retina:output PlacingPosition[index] int 1 run $prev_[axis].get();

                // Contact coordinates
                $targeted_[axis] += $origin_[axis];
                execute store result storage retina:output ContactCoordinates[index] double 0.0020833333333333333 run $targeted_[axis].get();

                // Total distance
                if ($nearest_axis == index) {
                    $total_distance = $delta_[axis];
                    $total_distance *= $[axis]0;
                }
            },
            [["X", "Y", "Z"], ["0", "1", "2"]]
        );
        $total_distance /= SCALE;
        if ($total_distance < 0) $total_distance *= -1;
        execute store result storage retina:output Distance double 0.0020833333333333333 run $total_distance.get();

        if (data storage retina:input {EndpointEntity: true}) execute summon minecraft:marker run {
            tag @s add retina.endpoint;
            data modify entity @s Pos set from storage retina:output ContactCoordinates;
            if ($end_particle) execute at @s run particle minecraft:electric_spark ~ ~ ~ 0 0 0 0 1 force @a;
        };
    }
    function entity() {
        // Target type
        data modify storage retina:output Target set value "ENTITY";

        // Targeted entity
        data modify storage retina:output TargetedEntity set value {UUID: [I; 0, 0, 0, 0], Pos: [0.0f, 0.0f, 0.0f]};
        execute as @e[type=!#retina:ignore, tag=retina.possible_target] if score @s retina.id = $closest_cuboid_id retina.__variable__ run {
            tag @s add retina.target;
            retina.hit:@s++;
        }
        data modify storage retina:data Entity set from entity @e[type=!#retina:ignore, tag=retina.target, limit=1];
        data modify storage retina:output TargetedEntity.UUID set from storage retina:data Entity.UUID;
        data modify storage retina:output TargetedEntity.Pos set from storage retina:data Entity.Pos;
        data remove storage retina:data Entity;

        // Contact surface
        data modify storage retina:output ContactSurface set from storage retina:data ContactSurface;

        // Contact coordinates
        data modify storage retina:output ContactCoordinates set value [0.0d, 0.0d, 0.0d];

        // I have no clue why X and Y need this but Z doesn't.
        if ($X0 < 0) $X0 += 480;
        if ($Y0 < 0) $Y0 += 480;
        
        Hardcode.repeatLists(
            ["[axis]", "_index"],
            () => {
                $targeted_[axis] += $origin_[axis];
                execute store result storage retina:output ContactCoordinates[_index] double 0.0020833333333333333 run $targeted_[axis].get();

                // Total distance
                if ($nearest_axis == _index) {
                    $total_distance = $delta_[axis];
                    $total_distance *= $[axis]0;
                }
            },
            [["X", "Y", "Z"], ["0", "1", "2"]]
        );
        $total_distance /= SCALE;
        if ($total_distance < 0) $total_distance *= -1;
        execute store result storage retina:output Distance double 0.0020833333333333333 run $total_distance.get();
        if (data storage retina:input {EndpointEntity: true}) execute summon minecraft:marker run {
            tag @s add retina.endpoint;
            data modify entity @s Pos set from storage retina:output ContactCoordinates;
            if ($end_particle) execute at @s run particle minecraft:electric_spark ~ ~ ~ 0 0 0 0 1 force @a;
        };
    }
}

$old_version_installed ?= scoreboard players add * retina 1;
if ($old_version_installed) {
    scoreboard objectives remove retina;
    scoreboard objectives remove retina.show_particle;
    scoreboard objectives remove retina.show_line;
    scoreboard objectives remove retina.raycast_count;
    scoreboard objectives remove retinacasttemp;
    kill @e[type=marker, tag=retina.ray];
    kill @e[type=marker, tag=retina.get_coordinates];
}
function uninstall() {}
return 1;